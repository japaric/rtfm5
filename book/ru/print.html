<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Real Time For the Masses</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="preface.html">Введение</a></li><li><a href="by-example.html"><strong aria-hidden="true">1.</strong> RTFM в примерах</a></li><li><ol class="section"><li><a href="by-example/app.html"><strong aria-hidden="true">1.1.</strong> Атрибут app</a></li><li><a href="by-example/resources.html"><strong aria-hidden="true">1.2.</strong> Ресурсы</a></li><li><a href="by-example/tasks.html"><strong aria-hidden="true">1.3.</strong> Задачи</a></li><li><a href="by-example/timer-queue.html"><strong aria-hidden="true">1.4.</strong> Очередь таймера</a></li><li><a href="by-example/singletons.html"><strong aria-hidden="true">1.5.</strong> Одиночки</a></li><li><a href="by-example/types-send-sync.html"><strong aria-hidden="true">1.6.</strong> Типы, Send и Sync</a></li><li><a href="by-example/new.html"><strong aria-hidden="true">1.7.</strong> Создание нового проекта</a></li><li><a href="by-example/tips.html"><strong aria-hidden="true">1.8.</strong> Советы и хитрости</a></li></ol></li><li><a href="internals.html"><strong aria-hidden="true">2.</strong> Под капотом</a></li><li><ol class="section"><li><a href="internals/ceilings.html"><strong aria-hidden="true">2.1.</strong> Ceiling analysis</a></li><li><a href="internals/tasks.html"><strong aria-hidden="true">2.2.</strong> Диспетчер задач</a></li><li><a href="internals/timer-queue.html"><strong aria-hidden="true">2.3.</strong> Очередь таймера</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Real Time For the Masses</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 align="center">Real Time For the Masses</h1>
<p align="center">Конкурентный фреймворк для создания систем реального времени</p>
<a class="header" href="#aВведение" id="aВведение"><h1>Введение</h1></a>
<p>Эта книга содержит документацию уровня пользователя фреймворком Real Time For the Masses
(RTFM). Описание API можно найти <a href="../api/rtfm/index.html">здесь</a>.</p>
<a class="header" href="#aВозможности" id="aВозможности"><h2>Возможности</h2></a>
<ul>
<li>
<p><strong>Задачи</strong> - единица конкуренции <sup class="footnote-reference"><a href="#1">1</a></sup>. Задачи могут <em>запускаться по событию</em>
(в ответ на асинхронный стимул) или вызываться программно по желанию.</p>
</li>
<li>
<p><strong>Передача сообщений</strong> между задачами. А именно, сообщения можно передавать
программным задачам в момент вызова.</p>
</li>
<li>
<p><strong>Очередь таймера</strong> <sup class="footnote-reference"><a href="#2">2</a></sup>. Программные задачи можно планировать на запуск в
определенный момент в будущем. Это свойство можно использовать, чтобы
реализовывать периодические задачи.</p>
</li>
<li>
<p>Поддержка приоритетов задач, и таким образом, <strong>вытесняющей многозадачности</strong>.</p>
</li>
<li>
<p><strong>Эффективное, свободное от гонок данных разделение памяти</strong> через хорошо
разграниченные критические секции на <em>основе приоритетов</em> <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p><strong>Выполнение без взаимной блокировки задач</strong>, гарантированное на этапе
компиляции. Это более сильная гарантия, чем предоставляемая
<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">стандартной абстракцией <code>Mutex</code></a>.</p>
</li>
</ul>
<ul>
<li>
<p><strong>Минимальные затраты на диспетчеризацию</strong>. Диспетчер задач имеет
минимальный след; основная часть работы по диспетчеризации делается аппаратно.</p>
</li>
<li>
<p><strong>Высокоэффективное использование памяти</strong>: Все задачи используют общий стек
вызовов и нет сильной зависимости от динамического распределителя памяти.</p>
</li>
<li>
<p><strong>Все устройства Cortex-M полностью поддерживаются</strong>.</p>
</li>
<li>
<p>Эта модель задач поддается известному анализу методом WCET (наихудшего
времени исполнения) и техникам анализа диспетчеризации. (Хотя мы еще не
разработали для дружественных инструментов для этого).</p>
</li>
</ul>
<a class="header" href="#aТребования" id="aТребования"><h2>Требования</h2></a>
<ul>
<li>
<p>Rust 1.31.0+</p>
</li>
<li>
<p>Программы нужно писать используя 2018 edition.</p>
</li>
</ul>
<a class="header" href="#aБлагодарности" id="aБлагодарности"><h2>Благодарности</h2></a>
<p>Эта библиотека основана на <a href="http://www.rtfm-lang.org/">языке RTFM</a>, созданном Embedded
Systems group в <a href="https://www.ltu.se/?l=en">Техническом Университете Luleå</a>, под рук.
<a href="https://www.ltu.se/staff/p/pln-1.11258?l=en">Prof. Per Lindgren</a>.</p>
<a class="header" href="#aСсылки" id="aСсылки"><h2>Ссылки</h2></a>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Eriksson, J., Häggström, F., Aittamaa, S., Kruglyak, A., &amp; Lindgren, P.
(2013, June). Real-time for the masses, step 1: Programming API and static
priority SRP kernel primitives. In Industrial Embedded Systems (SIES), 2013
8th IEEE International Symposium on (pp. 110-113). IEEE.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Lindgren, P., Fresk, E., Lindner, M., Lindner, A., Pereira, D., &amp; Pinho,
L. M. (2016). Abstract timers and their implementation onto the arm cortex-m
family of mcus. ACM SIGBED Review, 13(1), 48-53.</p>
</div>
<a class="header" href="#aЛицензия" id="aЛицензия"><h2>Лицензия</h2></a>
<p>Все исходные тексты (включая примеры кода) лицензированы либо под:</p>
<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> или
<a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or
<a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>)</li>
</ul>
<p>на Ваше усмотрение.</p>
<p>Текст книги лицензирован по условиям лицензий
Creative Commons CC-BY-SA v4.0 (<a href="LICENSE-CC-BY-SA">LICENSE-CC-BY-SA</a> или
<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">https://creativecommons.org/licenses/by-sa/4.0/legalcode</a>).</p>
<a class="header" href="#contribution" id="contribution"><h3>Contribution</h3></a>
<p>Если вы явно не заявляете иначе, любой взнос, преднамеренно представленный
для включения в эту работу, как определено в лицензии Apache-2.0, лицензируется, как указано выше, без каких-либо дополнительных условий.</p>
<a class="header" href="#rtfm-в-примерах" id="rtfm-в-примерах"><h1>RTFM в примерах</h1></a>
<p>Эта часть книги представляет фреймворк Real Time For the Masses (RTFM)
новым пользователям через примеры с растущей сложностью.</p>
<p>Все примеры в этой книге можно найти в <a href="https://github.com/japaric/cortex-m-rtfm">репозитории</a> проекта на GitHub,
и большинство примеров можно запустить на эмуляторе QEMU, поэтому никакого
специального оборудования не требуется их выполнять.</p>
<p>Чтобы запустить примеры на Вашем ноутбуке / ПК, Вам нужна программа
<code>qemu-system-arm</code>. Инструкции по настройке окружения для разработки
встраиваемых устройств, в том числе QEMU, Вы можете найти в <a href="https://rust-embedded.github.io/book/intro/install.html">the embedded Rust book</a>.</p>
<a class="header" href="#the-app-attribute" id="the-app-attribute"><h1>The <code>app</code> attribute</h1></a>
<p>Это наименьшая возможная программа на RTFM:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/smallest.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

// panic-handler crate
extern crate panic_semihosting;

use rtfm::app;

#[app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {}
};

#}</code></pre></pre>
<p>Все программы на RTFM используют атрибут <a href="../../api/cortex_m_rtfm_macros/attr.app.html"><code>app</code></a> (<code>#[app(..)]</code>). Этот атрибут
нужно применять к <code>const</code>-элементам, содержащим элементы. Атрибут <code>app</code> имеет
обязательный аргумент <code>device</code>, в качестве значения которому передается <em>путь</em>.
Этот путь должен указывать на библиотеку <em>устройства</em>, сгенерированную с помощью
<a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> <strong>v0.14.x</strong>. Атрибут <code>app</code> развернется в удобную точку входа,
поэтому нет необходимости использовать атрибут <a href="../../api/cortex_m_rt_macros/attr.entry.html"><code>cortex_m_rt::entry</code></a>.</p>
<blockquote>
<p><strong>ОТСТУПЛЕНИЕ</strong>: Некоторые из вас удивятся, почему мы используем ключевое слово <code>const</code> как
модуль, а не правильное <code>mod</code>. Причина в том, что использование атрибутов на
модулях требует feature gate, который требует ночную сборку. Чтобы заставить
RTFM работать на стабильной сборке, мы используем вместо него слово <code>const</code>.
Когда большая часть макросов 1.2 стабилизируются, мы прейдем от <code>const</code> к <code>mod</code> и в конце концов в атрибуту уровне приложения (<code>#![app]</code>).</p>
</blockquote>
<a class="header" href="#init" id="init"><h2><code>init</code></h2></a>
<p>Внутри псевдо-модуля атрибут <code>app</code> ожидает найти функцию инициализации, обозначенную
атрибутом <code>init</code>. Эта функция должна иметь сигнатуру <code>[unsafe] fn()</code>.</p>
<p>Эта функция инициализации будет первой частью запускаемого приложения.
Функция <code>init</code> запустится <em>с отключенными прерываниями</em> и будет иметь эксклюзивный
доступ к периферии Cortex-M и специфичной для устройства периферии через переменные
<code>core</code> and <code>device</code>, которые внедряются в область видимости <code>init</code> атрибутом <code>app</code>.
Не вся периферия Cortex-M доступна в <code>core</code>, потому что рантайм RTFM принимает владение
частью из неё -- более подробно см. структуру <a href="../../api/rtfm/struct.Peripherals.html"><code>rtfm::Peripherals</code></a>.</p>
<p>Переменные <code>static mut</code>, определённые в начале <code>init</code> будут преобразованы
в ссылки <code>&amp;'static mut</code> с безопасным доступом.</p>
<p>Пример ниже показывает типы переменных <code>core</code> и <code>device</code> и
демонстрирует безопасный доступ к переменной <code>static mut</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/init.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(c: init::Context) {
        static mut X: u32 = 0;

        // Cortex-M peripherals
        let _core: rtfm::Peripherals = c.core;

        // Device specific peripherals
        let _device: lm3s6965::Peripherals = c.device;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        hprintln!(&quot;init&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }
};

#}</code></pre></pre>
<p>Запуск примера напечатает  <code>init</code> в консоли и завершит процесс QEMU.</p>
<pre><code class="language-console">$ cargo run --example init
init
</code></pre>
<a class="header" href="#idle" id="idle"><h2><code>idle</code></h2></a>
<p>Функция, помеченная атрибутом <code>idle</code> может присутствовать в псевдо-модуле
опционально. Эта функция используется как специальная <em>задача ожидания</em> и должна иметь
сигнатуру <code>[unsafe] fn() - &gt; !</code>.</p>
<p>Когда она присутствует, рантайм запустит задачу <code>idle</code> после <code>init</code>. В отличие от
<code>init</code>, <code>idle</code> запустится <em>с включенными прерываниями</em> и не может завершиться,
поэтому будет работать бесконечно.</p>
<p>Когда функция <code>idle</code> определена, рантайм устанавливает бит <a href="https://developer.arm.com/products/architecture/cpu-architecture/m-profile/docs/100737/0100/power-management/sleep-mode/sleep-on-exit-bit">SLEEPONEXIT</a>, после чего
отправляет микроконтроллер в состояние сна после выполнения <code>init</code>.</p>
<p>Как и в <code>init</code>, переменные <code>static mut</code>будут преобразованы в ссылки <code>&amp;'static mut</code>
с безопасным доступом.</p>
<p>В примере ниже показан запуск <code>idle</code> после <code>init</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/idle.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        hprintln!(&quot;init&quot;).unwrap();
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        static mut X: u32 = 0;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        hprintln!(&quot;idle&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);

        loop {}
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example idle
init
idle
</code></pre>
<a class="header" href="#interrupt--exception" id="interrupt--exception"><h2><code>interrupt</code> / <code>exception</code></h2></a>
<p>Как Вы бы сделали с помощью библиотеки <code>cortex-m-rt</code>, Вы можете использовать атрибуты
<code>interrupt</code> и <code>exception</code> внутри псевдо-модуля <code>app</code>, чтобы определить обработчики
прерываний и исключений. В RTFM, мы называем обработчики прерываний и исключений
<em>аппаратными</em> задачами.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/interrupt.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        // Pends the UART0 interrupt but its handler won't run until *after*
        // `init` returns because interrupts are disabled
        rtfm::pend(Interrupt::UART0);

        hprintln!(&quot;init&quot;).unwrap();
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        // interrupts are enabled again; the `UART0` handler runs at this point

        hprintln!(&quot;idle&quot;).unwrap();

        rtfm::pend(Interrupt::UART0);

        debug::exit(debug::EXIT_SUCCESS);

        loop {}
    }

    #[interrupt]
    fn UART0(_: UART0::Context) {
        static mut TIMES: u32 = 0;

        // Safe access to local `static mut` variable
        *TIMES += 1;

        hprintln!(
            &quot;UART0 called {} time{}&quot;,
            *TIMES,
            if *TIMES &gt; 1 { &quot;s&quot; } else { &quot;&quot; }
        )
        .unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example interrupt
init
UART0 called 1 time
idle
UART0 called 2 times
</code></pre>
<p>До сих пор программы RTFM, которые мы видели не отличались от программ, которые
можно написать, используя только библиотеку <code>cortex-m-rt</code>. В следующем разделе
мы начнем знакомиться с функционалом, присущим только RTFM.</p>
<a class="header" href="#aРесурсы" id="aРесурсы"><h2>Ресурсы</h2></a>
<p>Одно из ограничений атрибутов, предоставляемых библиотекой <code>cortex-m-rt</code> является
то, что совместное использование данных (или периферии) между прерываниями,
или прерыванием и функцией <code>init</code>, требуют <code>cortex_m::interrupt::Mutex</code>, который
<em>всегда</em> требует отключения <em>всех</em> прерываний для доступа к данным. Отключение всех
прерываний не всегда необходимо для безопасности памяти, но компилятор не имеет
достаточно информации, чтобы оптимизировать доступ к разделяемым данным.</p>
<p>Атрибут <code>app</code> имеет полную картину приложения, поэтому может оптимизировать доступ к
<code>static</code>-переменным. В RTFM мы обращаемся к <code>static</code>-переменным, объявленным внутри
псевдо-модуля <code>app</code> как к <em>ресурсам</em>. Чтобы получить доступ к ресурсу, контекст
(<code>init</code>, <code>idle</code>, <code>interrupt</code> или <code>exception</code>) должен сначала определить
аргумент <code>resources</code> в соответствующем атрибуте.</p>
<p>В примере ниже два обработчика прерываний имеют доступ к одному и тому же ресурсу.
Никакого <code>Mutex</code> в этом случае не требуется, потому что оба обработчика запускаются
с одним приоритетом и никакого вытеснения быть не может.
К ресурсу <code>SHARED</code> можно получить доступ только из этих двух прерываний.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/resource.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    // A resource
    static mut SHARED: u32 = 0;

    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::UART0);
        rtfm::pend(Interrupt::UART1);
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        debug::exit(debug::EXIT_SUCCESS);

        // error: `SHARED` can't be accessed from this context
        // SHARED += 1;

        loop {}
    }

    // `SHARED` can be access from this context
    #[interrupt(resources = [SHARED])]
    fn UART0(mut c: UART0::Context) {
        *c.resources.SHARED += 1;

        hprintln!(&quot;UART0: SHARED = {}&quot;, c.resources.SHARED).unwrap();
    }

    // `SHARED` can be access from this context
    #[interrupt(resources = [SHARED])]
    fn UART1(mut c: UART1::Context) {
        *c.resources.SHARED += 1;

        hprintln!(&quot;UART1: SHARED = {}&quot;, c.resources.SHARED).unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example resource
UART0: SHARED = 1
UART1: SHARED = 2

</code></pre>
<a class="header" href="#aПриоритеты" id="aПриоритеты"><h2>Приоритеты</h2></a>
<p>Приоритет каждого прерывания можно определить в атрибутах <code>interrupt</code> и <code>exception</code>.
Невозможно установить приоритет любым другим способом, потому что рантайм
забирает владение прерыванием <code>NVIC</code>; также невозможно изменить приоритет
обработчика / задачи в рантайме. Благодаря этому ограничению у фреймворка
есть знание о <em>статических</em> приоритетах всех обработчиков прерываний и исключений.</p>
<p>Прерывания и исключения могут иметь приоритеты в интервале <code>1..=(1 &lt;&lt; NVIC_PRIO_BITS)</code>,
где <code>NVIC_PRIO_BITS</code> - константа, определённая в библиотеке <code>device</code>.
Задача <code>idle</code> имеет приоритет <code>0</code>, наименьший.</p>
<p>Ресурсы, совместно используемые обработчиками, работающими на разных приоритетах,
требуют критических секций для безопасности памяти. Фреймворк проверяет, что
критические секции используются, но <em>только где необходимы</em>: например,
критические секции не нужны для обработчика с наивысшим приоритетом, имеющим
доступ к ресурсу.</p>
<p>API критической секции, предоставляемое фреймворком RTFM (см. <a href="../../api/rtfm/trait.Mutex.html"><code>Mutex</code></a>),
основано на динамических приоритетах вместо отключения прерываний. Из этого следует,
что критические секции не будут допускать <em>запуск некоторых</em> обработчиков,
включая все соперничающие за ресурс, но будут позволять запуск обработчиков с
большим приоритетом не соперничащих за ресурс.</p>
<p>В примере ниже у нас есть 3 обработчика прерываний с приоритетами от одного
до трех. Два обработчика с низким приоритетом соперничают за ресурс <code>SHARED</code>.
Обработчик с низшим приоритетом должен заблокировать (<a href="../../api/rtfm/trait.Mutex.html#method.lock"><code>lock</code></a>) ресурс
<code>SHARED</code>, чтобы получить доступ к его данным, в то время как обработчик со
средним приоритетом может напрямую получать доступ к его данным. Обработчик
с наивысшим приоритетом может свободно вытеснять критическую секцию,
созданную обработчиком с низшим приоритетом.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/lock.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: u32 = 0;

    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::GPIOA);
    }

    // when omitted priority is assumed to be `1`
    #[interrupt(resources = [SHARED])]
    fn GPIOA(mut c: GPIOA::Context) {
        hprintln!(&quot;A&quot;).unwrap();

        // the lower priority task requires a critical section to access the data
        c.resources.SHARED.lock(|shared| {
            // data can only be modified within this critical section (closure)
            *shared += 1;

            // GPIOB will *not* run right now due to the critical section
            rtfm::pend(Interrupt::GPIOB);

            hprintln!(&quot;B - SHARED = {}&quot;, *shared).unwrap();

            // GPIOC does not contend for `SHARED` so it's allowed to run now
            rtfm::pend(Interrupt::GPIOC);
        });

        // critical section is over: GPIOB can now start

        hprintln!(&quot;E&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[interrupt(priority = 2, resources = [SHARED])]
    fn GPIOB(mut c: GPIOB::Context) {
        // the higher priority task does *not* need a critical section
        *c.resources.SHARED += 1;

        hprintln!(&quot;D - SHARED = {}&quot;, *c.resources.SHARED).unwrap();
    }

    #[interrupt(priority = 3)]
    fn GPIOC(_: GPIOC::Context) {
        hprintln!(&quot;C&quot;).unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example lock
A
B - SHARED = 1
C
D - SHARED = 2
E
</code></pre>
<a class="header" href="#aПоздние-ресурсы" id="aПоздние-ресурсы"><h2>Поздние ресурсы</h2></a>
<p>В отличие от обычных <code>static</code>-переменных, к которым должно быть присвоено
начальное значение, ресурсы можно инициализировать в рантайме.
Мы называем ресурсы, инициализируемые в рантайме <em>поздними</em>. Поздние ресурсы
полезны для <em>переноса</em> (как при передаче владения) периферии из <code>init</code> в
обработчики прерываний и исключений.</p>
<p>Поздние ресурсы определяются как обычные ресурсы, но им присваивается начальное
значение <code>()</code> (the unit value). <code>init</code> должен вернуть начальные значения для
всех поздних ресурсов, упакованные в структуру типа <code>init::LateResources</code>.</p>
<p>В примере ниже использованы поздние ресурсы, чтобы установить неблокированный,
односторонний канал между обработчиком прерывания <code>UART0</code> и функцией <code>idle</code>.
Очередь типа один производитель-один потребитель <a href="../../api/heapless/spsc/struct.Queue.html"><code>Queue</code></a> использована как канал.
Очередь разделена на элементы потребителя и поизводителя в <code>init</code> и каждый элемент
расположен в отдельном ресурсе; <code>UART0</code> владеет ресурсом произодителя, а <code>idle</code>
владеет ресурсом потребителя.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/late.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use heapless::{
    consts::*,
    spsc::{Consumer, Producer, Queue},
};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    // Late resources
    static mut P: Producer&lt;'static, u32, U4&gt; = ();
    static mut C: Consumer&lt;'static, u32, U4&gt; = ();

    #[init]
    fn init(_: init::Context) -&gt; init::LateResources {
        // NOTE: we use `Option` here to work around the lack of
        // a stable `const` constructor
        static mut Q: Option&lt;Queue&lt;u32, U4&gt;&gt; = None;

        *Q = Some(Queue::new());
        let (p, c) = Q.as_mut().unwrap().split();

        // Initialization of late resources
        init::LateResources { P: p, C: c }
    }

    #[idle(resources = [C])]
    fn idle(c: idle::Context) -&gt; ! {
        loop {
            if let Some(byte) = c.resources.C.dequeue() {
                hprintln!(&quot;received message: {}&quot;, byte).unwrap();

                debug::exit(debug::EXIT_SUCCESS);
            } else {
                rtfm::pend(Interrupt::UART0);
            }
        }
    }

    #[interrupt(resources = [P])]
    fn UART0(c: UART0::Context) {
        c.resources.P.enqueue(42).unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example late
received message: 42
</code></pre>
<a class="header" href="#static-ресурсы" id="static-ресурсы"><h2><code>static</code>-ресурсы</h2></a>
<p>Переменные типа <code>static</code> также можно использовать в качестве ресурсов. Задачи
могут получать только (разделяемые) <code>&amp;</code> ссылки на ресурсы, но блокировки не
нужны для доступа к данным. Вы можете думать о <code>static</code>-ресурсах как о простых
<code>static</code>-переменных, которые можно инициализировать в рантайме и иметь лучшие
правила видимости: Вы можете контролировать, какие задачи получают доступ к
переменной, чтобы переменная не была видна всем фунциям в область видимости,
где она была объявлена.</p>
<p>В примере ниже ключ загружен (или создан) в рантайме, а затем использован в двух
задачах, запущенных на разных приоритетах.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/static.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static KEY: u32 = ();

    #[init]
    fn init(_: init::Context) -&gt; init::LateResources {
        rtfm::pend(Interrupt::UART0);
        rtfm::pend(Interrupt::UART1);

        init::LateResources { KEY: 0xdeadbeef }
    }

    #[interrupt(resources = [KEY])]
    fn UART0(c: UART0::Context) {
        hprintln!(&quot;UART0(KEY = {:#x})&quot;, c.resources.KEY).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[interrupt(priority = 2, resources = [KEY])]
    fn UART1(c: UART1::Context) {
        hprintln!(&quot;UART1(KEY = {:#x})&quot;, c.resources.KEY).unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example static
UART1(KEY = 0xdeadbeef)
UART0(KEY = 0xdeadbeef)
</code></pre>
<a class="header" href="#aПрограммные-задачи" id="aПрограммные-задачи"><h1>Программные задачи</h1></a>
<p>RTFM обрабатывает прерывания и исключения как <em>аппаратные</em> задачи. Аппаратные
задачи могут вызываться устройством в ответ на события, такие как нажатие кнопки.
RTFM также поддерживает <em>программные</em> задачи, порождаемые программой из любого
контекста выполнения.</p>
<p>Программным задачам также можно назначать приоритет и диспетчеризовать из
обработчиков прерываний. RTFM требует определения свободных прерываний в блоке
<code>extern</code>, когда используются программные задачи; эти свободные прерывания будут использованы, чтобы диспетчеризовать программные задачи. Преимущество программных
задач перед аппаратными в том, что  на один обработчик прерывания можно назначить
множество задач.</p>
<p>Программные задачи определяются заданием функциям атрибута <code>task</code>. Чтобы было
возможно вызывать программные задачи, имя задачи нужно передать в аргументе
<code>spawn</code> контекста атрибута (<code>init</code>, <code>idle</code>, <code>interrupt</code>, etc.).</p>
<p>В примере ниже продемонстрированы три программных задачи, запускаемые на 2-х
разных приоритетах. Трем задачам назначены 2 обработчика прерываний.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/task.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(c: init::Context) {
        c.spawn.foo().unwrap();
    }

    #[task(spawn = [bar, baz])]
    fn foo(c: foo::Context) {
        hprintln!(&quot;foo&quot;).unwrap();

        // spawns `bar` onto the task scheduler
        // `foo` and `bar` have the same priority so `bar` will not run until
        // after `foo` terminates
        c.spawn.bar().unwrap();

        // spawns `baz` onto the task scheduler
        // `baz` has higher priority than `foo` so it immediately preempts `foo`
        c.spawn.baz().unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(priority = 2)]
    fn baz(_: baz::Context) {
        hprintln!(&quot;baz&quot;).unwrap();
    }

    // Interrupt handlers used to dispatch software tasks
    extern &quot;C&quot; {
        fn UART0();
        fn UART1();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example task
foo
baz
bar
</code></pre>
<a class="header" href="#aПередача-сообщений" id="aПередача-сообщений"><h2>Передача сообщений</h2></a>
<p>Другое преимущество программных задач - возможность передавать сообщения задачам
во время их вызова. Тип полезной нагрузки сообщения должен быть определен в
сигнатуре обработчика задачи.</p>
<p>Пример ниже демонстрирует три задачи, две из которых ожидают сообщения.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/message.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(c: init::Context) {
        c.spawn.foo(/* no message */).unwrap();
    }

    #[task(spawn = [bar])]
    fn foo(c: foo::Context) {
        static mut COUNT: u32 = 0;

        hprintln!(&quot;foo&quot;).unwrap();

        c.spawn.bar(*COUNT).unwrap();
        *COUNT += 1;
    }

    #[task(spawn = [baz])]
    fn bar(c: bar::Context, x: u32) {
        hprintln!(&quot;bar({})&quot;, x).unwrap();

        c.spawn.baz(x + 1, x + 2).unwrap();
    }

    #[task(spawn = [foo])]
    fn baz(c: baz::Context, x: u32, y: u32) {
        hprintln!(&quot;baz({}, {})&quot;, x, y).unwrap();

        if x + y &gt; 4 {
            debug::exit(debug::EXIT_SUCCESS);
        }

        c.spawn.foo().unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example message
foo
bar(0)
baz(1, 2)
foo
bar(1)
baz(2, 3)
</code></pre>
<a class="header" href="#aЁмкость" id="aЁмкость"><h2>Ёмкость</h2></a>
<p>Диспетчеры задач <em>не</em> используют динамическое выделение памяти. Память
необходимая для размещения сообщений, резервируется статически. Фреймворк
зарезервирует достаточно памяти для каждого контекста, чтобы можно было вызвать
каждую задачу как минимум единожды. Это разумно по умолчанию, но
&quot;внутреннюю&quot; ёмкость каждой задачи можно контролировать используя аргумент
<code>capacity</code> атрибута <code>task</code>.</p>
<p>В примере ниже установлена ёмкость программной задачи <code>foo</code> на 4. Если ёмкость
не определена, тогда второй вызов <code>spawn.foo</code> в <code>UART0</code> вызовет ошибку.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/capacity.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::UART0);
    }

    #[interrupt(spawn = [foo, bar])]
    fn UART0(c: UART0::Context) {
        c.spawn.foo(0).unwrap();
        c.spawn.foo(1).unwrap();
        c.spawn.foo(2).unwrap();
        c.spawn.foo(3).unwrap();

        c.spawn.bar().unwrap();
    }

    #[task(capacity = 4)]
    fn foo(_: foo::Context, x: u32) {
        hprintln!(&quot;foo({})&quot;, x).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    // Interrupt handlers used to dispatch software tasks
    extern &quot;C&quot; {
        fn UART1();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example capacity
foo(0)
foo(1)
foo(2)
foo(3)
bar
</code></pre>
<a class="header" href="#aОчередь-таймера" id="aОчередь-таймера"><h1>Очередь таймера</h1></a>
<p>Когда включена опция <code>timer-queue</code>, фреймворк RTFM включает
<em>глобальную очередь таймера</em>, которую приложения могут использовать, чтобы
<em>планировать</em> программные задачи на запуск через некоторое время в будущем.</p>
<p>Чтобы была возможность планировать программную задачу, имя задачи должно
присутствовать в аргументе <code>schedule</code> контекста атрибута. Когда задача
планируется, момент (<a href="../../api/rtfm/struct.Instant.html"><code>Instant</code></a>), в который задачу нужно запустить, нужно передать
как первый аргумент вызова <code>schedule</code>.</p>
<p>Рантайм RTFM включает монотонный, растущий только вверх, 32-битный таймер,
значение которого можно запросить конструктором <code>Instant::now</code>. Время (<a href="../../api/rtfm/struct.Duration.html"><code>Duration</code></a>)
можно передать в <code>Instant::now()</code>, чтобы получить <code>Instant</code> в будущем. Монотонный
таймер отключен пока запущен <code>init</code>, поэтому <code>Instant::now()</code> всегда возвращает
значение <code>Instant(0 /* циклов тактовой частоты */)</code>; таймер включается сразу перед
включением прерываний и запуском <code>idle</code>.</p>
<p>В примере ниже две задачи планируются из <code>init</code>: <code>foo</code> и <code>bar</code>. <code>foo</code> -
запланирована на запуск через 8 миллионов тактов в будущем. Кроме того, <code>bar</code>
запланирован на запуск через 4 миллиона тактов в будущем. <code>bar</code> запустится раньше
<code>foo</code>, т.к. он запланирован на запуск первым.</p>
<blockquote>
<p><strong>ВАЖНО</strong>: Примеры, использующие API <code>schedule</code> или абстракцию <code>Instant</code>
<strong>не</strong> будут правильно работать на QEMU, потому что функциональность счетчика
тактов Cortex-M не реализована в <code>qemu-system-arm</code>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/schedule.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::hprintln;
use rtfm::Instant;

// NOTE: does NOT work on QEMU!
#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(schedule = [foo, bar])]
    fn init(c: init::Context) {
        let now = Instant::now();

        hprintln!(&quot;init @ {:?}&quot;, now).unwrap();

        // Schedule `foo` to run 8e6 cycles (clock cycles) in the future
        c.schedule.foo(now + 8_000_000.cycles()).unwrap();

        // Schedule `bar` to run 4e6 cycles in the future
        c.schedule.bar(now + 4_000_000.cycles()).unwrap();
    }

    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo  @ {:?}&quot;, Instant::now()).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar  @ {:?}&quot;, Instant::now()).unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};

#}</code></pre></pre>
<p>Запуск программы на реальном оборудовании производит следующий вывод в консоли:</p>
<pre><code class="language-text">init @ Instant(0)
bar  @ Instant(4000236)
foo  @ Instant(8000173)
</code></pre>
<a class="header" href="#aПериодические-задачи" id="aПериодические-задачи"><h2>Периодические задачи</h2></a>
<p>Программные задачи имеют доступ к <code>Instant</code> в момент, когда были запланированы
на запуск через переменную <code>scheduled</code>. Эта информация и API <code>schedule</code> могут
быть использованы для реализации периодических задач, как показано в примере ниже.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/periodic.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::hprintln;
use rtfm::Instant;

const PERIOD: u32 = 8_000_000;

// NOTE: does NOT work on QEMU!
#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(schedule = [foo])]
    fn init(c: init::Context) {
        c.schedule.foo(Instant::now() + PERIOD.cycles()).unwrap();
    }

    #[task(schedule = [foo])]
    fn foo(c: foo::Context) {
        let now = Instant::now();
        hprintln!(&quot;foo(scheduled = {:?}, now = {:?})&quot;, c.scheduled, now).unwrap();

        c.schedule.foo(c.scheduled + PERIOD.cycles()).unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};

#}</code></pre></pre>
<p>Это вывод, произведенный примером. Заметьте, что есть смещение / колебание нуля
даже если <code>schedule.foo</code> была вызвана в <em>конце</em> <code>foo</code>. Использование
<code>Instant::now</code> вместо <code>scheduled</code> имело бы влияние на смещение / колебание.</p>
<pre><code class="language-text">foo(scheduled = Instant(8000000), now = Instant(8000196))
foo(scheduled = Instant(16000000), now = Instant(16000196))
foo(scheduled = Instant(24000000), now = Instant(24000196))
</code></pre>
<a class="header" href="#aБазовое-время" id="aБазовое-время"><h2>Базовое время</h2></a>
<p>Для задач, планируемых из <code>init</code> мы имеем точную информацию о их планируемом
(<code>scheduled</code>) времени. Для аппаратных задач нет <code>scheduled</code> времени, потому
что эти задачи асинхронны по природе. Для аппаратных задач рантайм предоставляет
время старта (<code>start</code>), которе отражает время, в которое обработчик прерывания
был запущен.</p>
<p>Заметьте, что <code>start</code> <strong>не</strong> равен времени возникновения события, вызвавшего
задачу. В зависимости от приоритета задачи и загрузки системы время
<code>start</code> может быть сильно отдалено от времени возникновения события.</p>
<p>Какое по Вашему мнению будет значение <code>scheduled</code> для программных задач которые
<em>вызываются</em>, вместо того чтобы планироваться? Ответ в том, что вызываемые
задачи наследуют <em>базовое</em> время контекста, в котором вызваны. Бызовым для
аппаратных задач является <code>start</code>, базовым для программных задач - <code>scheduled</code>
и базовым для <code>init</code> - <code>start = Instant(0)</code>. <code>idle</code> на сомом деле не имеет
базового времени но задачи, вызванные из него будут использовать <code>Instant::now()</code>
как их базовое время.</p>
<p>Пример ниже демонстрирует разное значение <em>базового времени</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/baseline.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

// NOTE: does NOT properly work on QEMU
#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(c: init::Context) {
        hprintln!(&quot;init(baseline = {:?})&quot;, c.start).unwrap();

        // `foo` inherits the baseline of `init`: `Instant(0)`
        c.spawn.foo().unwrap();
    }

    #[task(schedule = [foo])]
    fn foo(c: foo::Context) {
        static mut ONCE: bool = true;

        hprintln!(&quot;foo(baseline = {:?})&quot;, c.scheduled).unwrap();

        if *ONCE {
            *ONCE = false;

            rtfm::pend(Interrupt::UART0);
        } else {
            debug::exit(debug::EXIT_SUCCESS);
        }
    }

    #[interrupt(spawn = [foo])]
    fn UART0(c: UART0::Context) {
        hprintln!(&quot;UART0(baseline = {:?})&quot;, c.start).unwrap();

        // `foo` inherits the baseline of `UART0`: its `start` time
        c.spawn.foo().unwrap();
    }

    extern &quot;C&quot; {
        fn UART1();
    }
};

#}</code></pre></pre>
<p>Запуск программы на реальном оборудовании произведет следующий вывод в консоли:</p>
<pre><code class="language-text">init(baseline = Instant(0))
foo(baseline = Instant(0))
UART0(baseline = Instant(904))
foo(baseline = Instant(904))
</code></pre>
<a class="header" href="#aОдиночки" id="aОдиночки"><h1>Одиночки</h1></a>
<p>Атрибут <code>app</code> знает о библиотеке <a href="../../api/owned_singleton/index.html"><code>owned-singleton</code></a> и её атрибуте <a href="../../api/owned_singleton_macros/attr.Singleton.html"><code>Singleton</code></a>.
Когда этот атрибут применяется к одному из ресурсов, рантайм производит для Вас
<code>unsafe</code> инициализацию одиночки, проверяя, что только один экземпляр одиночки
когда-либо создан.</p>
<p>Заметьте, что когда Вы используете атрибут <code>Singleton</code>, Вым нужно иметь
<code>owned_singleton</code> в зависимостях.</p>
<p>В примере ниже атрибутом <code>Singleton</code> аннотирован массив памяти,
а экземпляр одиночки использован как фиксированный по размеру пул памяти
с помощью одной из абстракций <a href="https://crates.io/crates/alloc-singleton"><code>alloc-singleton</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{{#include ../../../../examples/singleton.rs}}
#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example singleton
bar(2)
foo(1)
</code></pre>
<a class="header" href="#aТипы-send-и-sync" id="aТипы-send-и-sync"><h1>Типы, Send и Sync</h1></a>
<p>Атрибут <code>app</code> вводит контекст, коллекцию переменных в каждую из функций.
Все эти переменные имеют предсказуемые, неанонимные типы, поэтому Вы можете
писать простые функции, получающие их как аргументы.</p>
<p>Описание API определяет как эти типы эти типы генерируются из входных данных.
Вы можете также сгенерировать документацию для Вашей бинарной библиотеки
(<code>cargo doc --bin &lt;name&gt;</code>); в документации Вы найдете структуры <code>Context</code>
(например <code>init::Context</code> и <code>idle::Context</code>), чьи поля представляют переменные
включенные в каждую функцию.</p>
<p>В примере ниже сгенерированы разные типы с помощью атрибута <code>app</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/types.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::debug;
use rtfm::{Exclusive, Instant};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: u32 = 0;

    #[init(schedule = [foo], spawn = [foo])]
    fn init(c: init::Context) {
        let _: Instant = c.start;
        let _: rtfm::Peripherals = c.core;
        let _: lm3s6965::Peripherals = c.device;
        let _: init::Schedule = c.schedule;
        let _: init::Spawn = c.spawn;

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[exception(schedule = [foo], spawn = [foo])]
    fn SVCall(c: SVCall::Context) {
        let _: Instant = c.start;
        let _: SVCall::Schedule = c.schedule;
        let _: SVCall::Spawn = c.spawn;
    }

    #[interrupt(resources = [SHARED], schedule = [foo], spawn = [foo])]
    fn UART0(c: UART0::Context) {
        let _: Instant = c.start;
        let _: resources::SHARED = c.resources.SHARED;
        let _: UART0::Schedule = c.schedule;
        let _: UART0::Spawn = c.spawn;
    }

    #[task(priority = 2, resources = [SHARED], schedule = [foo], spawn = [foo])]
    fn foo(c: foo::Context) {
        let _: Instant = c.scheduled;
        let _: Exclusive&lt;u32&gt; = c.resources.SHARED;
        let _: foo::Resources = c.resources;
        let _: foo::Schedule = c.schedule;
        let _: foo::Spawn = c.spawn;
    }

    extern &quot;C&quot; {
        fn UART1();
    }
};

#}</code></pre></pre>
<a class="header" href="#send" id="send"><h2><code>Send</code></h2></a>
<p><a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a> - маркерный типаж (trait) для &quot;типов, которые можно передавать через границы
потоков&quot;, как это определено в <code>core</code>. В контексте RTFM типаж <code>Send</code> необходим
только там, где возможна передача значения между задачами, запускаемыми на
<em>разных</em> приоритетах. Это возникает в нескольких случаях: при передаче сообщений,
в совместно используемых <code>static mut</code> ресурсах и инициализации поздних ресурсов.</p>
<p>Атрибут <code>app</code> проверит, что <code>Send</code> реализован, где необходимо, поэтому Вам не
стоит волноваться об этом. Более важно знать, где Вам <em>не</em> нужен типаж <code>Send</code>:
в типах, передаваемых между задачами с <em>одинаковым</em> приоритетом. Это возникает
в двух случаях: при передаче сообщений и в совместно используемых <code>static mut</code>
ресурсах.</p>
<p>В примере ниже показано, где можно использовать типы, не реализующие <code>Send</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! `examples/not-send.rs`

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_halt;

use core::marker::PhantomData;

use cortex_m_semihosting::debug;
use rtfm::app;

pub struct NotSend {
    _0: PhantomData&lt;*const ()&gt;,
}

#[app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: Option&lt;NotSend&gt; = None;

    #[init(spawn = [baz, quux])]
    fn init(c: init::Context) {
        c.spawn.baz().unwrap();
        c.spawn.quux().unwrap();
    }

    #[task(spawn = [bar])]
    fn foo(c: foo::Context) {
        // scenario 1: message passed to task that runs at the same priority
        c.spawn.bar(NotSend { _0: PhantomData }).ok();
    }

    #[task]
    fn bar(_: bar::Context, _x: NotSend) {
        // scenario 1
    }

    #[task(priority = 2, resources = [SHARED])]
    fn baz(mut c: baz::Context) {
        // scenario 2: resource shared between tasks that run at the same priority
        *c.resources.SHARED = Some(NotSend { _0: PhantomData });
    }

    #[task(priority = 2, resources = [SHARED])]
    fn quux(mut c: quux::Context) {
        // scenario 2
        let _not_send = c.resources.SHARED.take().unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    extern &quot;C&quot; {
        fn UART0();
        fn UART1();
    }
};

#}</code></pre></pre>
<a class="header" href="#sync" id="sync"><h2><code>Sync</code></h2></a>
<p>Похожая ситуация, <a href="https://doc.rust-lang.org/core/marker/trait.Sync.html"><code>Sync</code></a> -  маркерный типаж для &quot;типов, на которых можно
ссылаться в разных потоках&quot;, как это определено в <code>core</code>. В контексте RTFM
типаж <code>Sync</code> необходим только там, где возможны две или более задачи,
запускаемые на разных приоритетах, чтобы захватить разделяемую ссылку на
ресурс. Это возникает только  совместно используемых <code>static</code>-ресурсах.</p>
<p>Атрибут <code>app</code> проверит, что <code>Sync</code> реализован, где необходимо, но важно знать,
где ограничение <code>Sync</code> не требуется: в <code>static</code>-ресурсах, разделяемых между
задачами с <em>одинаковым</em> приоритетом.</p>
<p>В примере ниже показано, где можно использовать типы, не реализующие <code>Sync</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! `examples/not-sync.rs`

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_halt;

use core::marker::PhantomData;

use cortex_m_semihosting::debug;

pub struct NotSync {
    _0: PhantomData&lt;*const ()&gt;,
}

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static SHARED: NotSync = NotSync { _0: PhantomData };

    #[init]
    fn init(_: init::Context) {
        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(resources = [SHARED])]
    fn foo(c: foo::Context) {
        let _: &amp;NotSync = c.resources.SHARED;
    }

    #[task(resources = [SHARED])]
    fn bar(c: bar::Context) {
        let _: &amp;NotSync = c.resources.SHARED;
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};

#}</code></pre></pre>
<a class="header" href="#aСоздание-нового-проекта" id="aСоздание-нового-проекта"><h1>Создание нового проекта</h1></a>
<p>Теперь, когда Вы изучили основные возможности фреймворка RTFM, Вы можете
попробовать его использовать на Вашем оборудовании следуя этим инструкциям.</p>
<ol>
<li>Создайте экземпляр из шаблона <a href="https://github.com/rust-embedded/cortex-m-quickstart#cortex-m-quickstart"><code>cortex-m-quickstart</code></a>.</li>
</ol>
<pre><code class="language-console">$ # например используя `cargo-generate`
$ cargo generate \
    --git https://github.com/rust-embedded/cortex-m-quickstart \
    --name app

$ # следуйте остальным инструкциям
</code></pre>
<ol start="2">
<li>Добавьте крейт устройства, сгенерированный с помощью <a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> <strong>v0.14.x</strong>,
или библиотеку отладочной платы, у которой в зависимостях одно из устройств.
Убедитесь, что опция <code>rt</code> крейта включена.</li>
</ol>
<p>В этом примере я покажу использование крейта устройства <a href="https://crates.io/crates/lm3s6965"><code>lm3s6965</code></a>.
Эта библиотека не имеет Cargo-опции <code>rt</code>; эта опция всегда включена.</p>
<p>Этот крейт устройства предоставляет линковочный скрипт с макетом памяти
целевого устройства, поэтому <code>memory.x</code> и <code>build.rs</code> не нужно удалять.</p>
<pre><code class="language-console">$ cargo add lm3s6965 --vers 0.1.3

$ rm memory.x build.rs
</code></pre>
<ol start="3">
<li>Добавьте библиотеку <code>cortex-m-rtfm</code> как зависимость, и если необходимо,
включите опцию <code>timer-queue</code>.</li>
</ol>
<pre><code class="language-console">$ cargo add cortex-m-rtfm --allow-prerelease --upgrade=none
</code></pre>
<ol start="4">
<li>Напишите программу RTFM.</li>
</ol>
<p>Здесь я буду использовать пример <code>init</code> из библиотеки <code>cortex-m-rtfm</code>.</p>
<pre><code class="language-console">$ curl \
    -L https://github.com/japaric/cortex-m-rtfm/raw/v0.4.0-beta.1/examples/init.rs \
    &gt; src/main.rs
</code></pre>
<p>Этот пример зависит от библиотеки <code>panic-semihosting</code>:</p>
<pre><code class="language-console">$ cargo add panic-semihosting
</code></pre>
<ol start="5">
<li>Соберите его, загрузите в микроконтроллер и запустите.</li>
</ol>
<pre><code class="language-console">$ # ПРИМЕЧАНИЕ: Я раскомментировал опцию `runner` в `.cargo/config`
$ cargo run
init
</code></pre>
<a class="header" href="#aСоветы-и-хитрости" id="aСоветы-и-хитрости"><h1>Советы и хитрости</h1></a>
<a class="header" href="#aОбобщенное-программирование-generics" id="aОбобщенное-программирование-generics"><h2>Обобщенное программирование (Generics)</h2></a>
<p>Ресурсы, совместно используемые двумя или более задачами, реализуют трейт <code>Mutex</code>
во <em>всех</em> контекстах, даже в тех, где для доступа к данным не требуются
критические секции. Это позволяет легко писать обобщенный код оперирующий
ресурсами, который можно вызывать из различных задач. Вот такой пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/generics.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;
use rtfm::Mutex;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: u32 = 0;

    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::UART0);
        rtfm::pend(Interrupt::UART1);
    }

    #[interrupt(resources = [SHARED])]
    fn UART0(c: UART0::Context) {
        static mut STATE: u32 = 0;

        hprintln!(&quot;UART0(STATE = {})&quot;, *STATE).unwrap();

        advance(STATE, c.resources.SHARED);

        rtfm::pend(Interrupt::UART1);

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[interrupt(priority = 2, resources = [SHARED])]
    fn UART1(mut c: UART1::Context) {
        static mut STATE: u32 = 0;

        hprintln!(&quot;UART1(STATE = {})&quot;, *STATE).unwrap();

        // just to show that `SHARED` can be accessed directly and ..
        *c.resources.SHARED += 0;
        // .. also through a (no-op) `lock`
        c.resources.SHARED.lock(|shared| *shared += 0);

        advance(STATE, c.resources.SHARED);
    }
};

fn advance(state: &amp;mut u32, mut shared: impl Mutex&lt;T = u32&gt;) {
    *state += 1;

    let (old, new) = shared.lock(|shared| {
        let old = *shared;
        *shared += *state;
        (old, *shared)
    });

    hprintln!(&quot;SHARED: {} -&gt; {}&quot;, old, new).unwrap();
}

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example generics
UART1(STATE = 0)
SHARED: 0 -&gt; 1
UART0(STATE = 0)
SHARED: 1 -&gt; 2
UART1(STATE = 1)
SHARED: 2 -&gt; 4
</code></pre>
<p>Это также позволяет Вам изменять статические приоритеты задач без
переписывания кода. Если Вы единообразно используете <code>lock</code>-и для доступа
к данным в разделяемых ресурсах, тогда Ваш код продолжит компилироваться,
когда Вы измените приоритет задач.</p>
<a class="header" href="#aЗапуск-задач-из-ОЗУ" id="aЗапуск-задач-из-ОЗУ"><h2>Запуск задач из ОЗУ</h2></a>
<p>Главной целью переноса описания программы на RTFM в атрибуты в
RTFM v0.4.x была возможность взаимодействия с другими атрибутами.
Напримерe, атрибут <code>link_section</code> можно применять к задачам, чтобы разместить
их в ОЗУ; это может улучшить производительность в некоторых случаях.</p>
<blockquote>
<p><strong>ВАЖНО</strong>: Обычно атрибуты <code>link_section</code>, <code>export_name</code> и <code>no_mangle</code>
очень мощные, но их легко использовать неправильно. Неверное использование
любого из этих атрибутов может вызвать неопределенное поведение;
Вам следует всегда предпочитать использование безопасных, высокоуровневых
атрибутов вокруг них, таких как атрибуты <code>interrupt</code> и <code>exception</code>
из <code>cortex-m-rt</code>.</p>
<p>В особых случаях функций RAM нет безопасной абстракции в <code>cortex-m-rt</code>
v0.6.5 но создано <a href="https://github.com/rust-embedded/cortex-m-rt/pull/100">RFC</a> для добавления атрибута <code>ramfunc</code> в будущем релизе.</p>
</blockquote>
<p>В примере ниже показано как разместить высокоприоритетную задачу <code>bar</code> в ОЗУ.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/ramfunc.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [bar])]
    fn init(c: init::Context) {
        c.spawn.bar().unwrap();
    }

    #[inline(never)]
    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    // run this task from RAM
    #[inline(never)]
    #[link_section = &quot;.data.bar&quot;]
    #[task(priority = 2, spawn = [foo])]
    fn bar(c: bar::Context) {
        c.spawn.foo().unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();

        // run the task dispatcher from RAM
        #[link_section = &quot;.data.UART1&quot;]
        fn UART1();
    }
};

#}</code></pre></pre>
<p>Запуск этой программы произведет ожидаемый вывод.</p>
<pre><code class="language-console">$ cargo run --example ramfunc
foo
</code></pre>
<p>Можно посмотреть на вывод <code>cargo-nm</code>, чтобы убедиться, что <code>bar</code> расположен в ОЗУ
(<code>0x2000_0000</code>), тогда как <code>foo</code> расположен во Flash (<code>0x0000_0000</code>).</p>
<pre><code class="language-console">$ cargo nm --example ramfunc --release | grep ' foo::'
20000100 B foo::FREE_QUEUE::ujkptet2nfdw5t20
200000dc B foo::INPUTS::thvubs85b91dg365
000002c6 T foo::sidaht420cg1mcm8
</code></pre>
<pre><code class="language-console">$ cargo nm --example ramfunc --release | grep ' bar::'
20000100 B bar::FREE_QUEUE::lk14244m263eivix
200000dc B bar::INPUTS::mi89534s44r1mnj1
20000000 T bar::ns9009yhw2dc2y25
</code></pre>
<a class="header" href="#binds" id="binds"><h2><code>binds</code></h2></a>
<p><strong>ПРИМЕЧАНИЕ</strong>: Требуется RTFM не ниже 0.4.2</p>
<p>Вы можете давать аппаратным задачам имена похожие на имена обычных задач.
Для этого нужно использовать аргумент <code>binds</code>: Вы называете функцию
по своему желанию и назначаете ей прерывание / исключение
через аргумент <code>binds</code>. <code>Spawn</code> и другие служебные типы будут размещены в модуле,
названном в соответствии с названием функции, а не прерывания / исключения.
Давайте посмотрим пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/binds.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

// `examples/interrupt.rs` rewritten to use `binds`
#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::UART0);

        hprintln!(&quot;init&quot;).unwrap();
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        hprintln!(&quot;idle&quot;).unwrap();

        rtfm::pend(Interrupt::UART0);

        debug::exit(debug::EXIT_SUCCESS);

        loop {}
    }

    #[interrupt(binds = UART0)]
    fn foo(_: foo::Context) {
        static mut TIMES: u32 = 0;

        *TIMES += 1;

        hprintln!(
            &quot;foo called {} time{}&quot;,
            *TIMES,
            if *TIMES &gt; 1 { &quot;s&quot; } else { &quot;&quot; }
        )
        .unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example binds
init
foo called 1 time
idle
foo called 2 times
</code></pre>
<a class="header" href="#aПод-капотом" id="aПод-капотом"><h1>Под капотом</h1></a>
<p>В этом разделе описывабтся внутренности фркймворка на <em>высоком уровне</em>.
Низкоуровневые тонкости, такие как парсинг и кодогенерация производимые
процедурным макросом (<code>#[app]</code>) здесь объясняться не будут. Мы сосредоточимся
на анализе пользовательской спецификации и структурах данных, используемых
рантаймом.</p>
<a class="header" href="#ceiling-analysis" id="ceiling-analysis"><h1>Ceiling analysis</h1></a>
<p><strong>TODO</strong></p>
<a class="header" href="#task-dispatcher" id="task-dispatcher"><h1>Task dispatcher</h1></a>
<p><strong>TODO</strong></p>
<a class="header" href="#timer-queue" id="timer-queue"><h1>Timer queue</h1></a>
<p><strong>TODO</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
