<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Real Time For the Masses</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="by-example.html"><strong aria-hidden="true">1.</strong> RTFM by example</a></li><li><ol class="section"><li><a href="by-example/app.html"><strong aria-hidden="true">1.1.</strong> The app attribute</a></li><li><a href="by-example/resources.html"><strong aria-hidden="true">1.2.</strong> Resources</a></li><li><a href="by-example/tasks.html"><strong aria-hidden="true">1.3.</strong> Tasks</a></li><li><a href="by-example/timer-queue.html"><strong aria-hidden="true">1.4.</strong> Timer queue</a></li><li><a href="by-example/types-send-sync.html"><strong aria-hidden="true">1.5.</strong> Types, Send and Sync</a></li><li><a href="by-example/new.html"><strong aria-hidden="true">1.6.</strong> Starting a new project</a></li><li><a href="by-example/tips.html"><strong aria-hidden="true">1.7.</strong> Tips &amp; tricks</a></li></ol></li><li><a href="internals.html"><strong aria-hidden="true">2.</strong> Under the hood</a></li><li><ol class="section"><li><a href="internals/interrupt-configuration.html"><strong aria-hidden="true">2.1.</strong> Interrupt configuration</a></li><li><a href="internals/non-reentrancy.html"><strong aria-hidden="true">2.2.</strong> Non-reentrancy</a></li><li><a href="internals/access.html"><strong aria-hidden="true">2.3.</strong> Access control</a></li><li><a href="internals/late-resources.html"><strong aria-hidden="true">2.4.</strong> Late resources</a></li><li><a href="internals/critical-sections.html"><strong aria-hidden="true">2.5.</strong> Critical sections</a></li><li><a href="internals/ceilings.html"><strong aria-hidden="true">2.6.</strong> Ceiling analysis</a></li><li><a href="internals/tasks.html"><strong aria-hidden="true">2.7.</strong> Software tasks</a></li><li><a href="internals/timer-queue.html"><strong aria-hidden="true">2.8.</strong> Timer queue</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Real Time For the Masses</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 align="center">Real Time For the Masses</h1>
<p align="center">A concurrency framework for building real time systems</p>
<a class="header" href="#preface" id="preface"><h1>Preface</h1></a>
<p>This book contains user level documentation for the Real Time For the Masses
(RTFM) framework. The API reference can be found <a href="../api/rtfm/index.html">here</a>.</p>
<p>There is a translation of this book in <a href="../ru/index.html">Russian</a>.</p>
<p><strong>HEADS UP</strong> This is an <strong>alpha</strong> pre-release; there may be breaking changes in
the API and semantics before a proper release is made.</p>
<a class="header" href="#features" id="features"><h2>Features</h2></a>
<ul>
<li>
<p><strong>Tasks</strong> as the unit of concurrency <sup class="footnote-reference"><a href="#1">1</a></sup>. Tasks can be <em>event triggered</em>
(fired in response to asynchronous stimuli) or spawned by the application on
demand.</p>
</li>
<li>
<p><strong>Message passing</strong> between tasks. Specifically, messages can be passed to
software tasks at spawn time.</p>
</li>
<li>
<p><strong>A timer queue</strong> <sup class="footnote-reference"><a href="#2">2</a></sup>. Software tasks can be scheduled to run at some time
in the future. This feature can be used to implement periodic tasks.</p>
</li>
<li>
<p>Support for prioritization of tasks and, thus, <strong>preemptive multitasking</strong>.</p>
</li>
<li>
<p><strong>Efficient and data race free memory sharing</strong> through fine grained <em>priority
based</em> critical sections <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p><strong>Deadlock free execution</strong> guaranteed at compile time. This is an stronger
guarantee than what's provided by <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">the standard <code>Mutex</code>
abstraction</a>.</p>
</li>
</ul>
<ul>
<li>
<p><strong>Minimal scheduling overhead</strong>. The task scheduler has minimal software
footprint; the hardware does the bulk of the scheduling.</p>
</li>
<li>
<p><strong>Highly efficient memory usage</strong>: All the tasks share a single call stack and
there's no hard dependency on a dynamic memory allocator.</p>
</li>
<li>
<p><strong>All Cortex-M devices are supported</strong>. The core features of RTFM are
supported on all Cortex-M devices. The timer queue is currently only supported
on ARMv7-M devices.</p>
</li>
<li>
<p>This task model is amenable to known WCET (Worst Case Execution Time) analysis
and scheduling analysis techniques. (Though we haven't yet developed Rust
friendly tooling for that.)</p>
</li>
</ul>
<a class="header" href="#requirements" id="requirements"><h2>Requirements</h2></a>
<ul>
<li>
<p>Rust 1.36.0+</p>
</li>
<li>
<p>Applications must be written using the 2018 edition.</p>
</li>
</ul>
<a class="header" href="#acknowledgments" id="acknowledgments"><h2>Acknowledgments</h2></a>
<p>This crate is based on <a href="http://www.rtfm-lang.org/">the RTFM language</a> created by the Embedded
Systems group at <a href="https://www.ltu.se/?l=en">Luleå University of Technology</a>, led by <a href="https://www.ltu.se/staff/p/pln-1.11258?l=en">Prof. Per
Lindgren</a>.</p>
<a class="header" href="#references" id="references"><h2>References</h2></a>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Eriksson, J., Häggström, F., Aittamaa, S., Kruglyak, A., &amp; Lindgren, P.
(2013, June). Real-time for the masses, step 1: Programming API and static
priority SRP kernel primitives. In Industrial Embedded Systems (SIES), 2013
8th IEEE International Symposium on (pp. 110-113). IEEE.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Lindgren, P., Fresk, E., Lindner, M., Lindner, A., Pereira, D., &amp; Pinho,
L. M. (2016). Abstract timers and their implementation onto the arm cortex-m
family of mcus. ACM SIGBED Review, 13(1), 48-53.</p>
</div>
<a class="header" href="#license" id="license"><h2>License</h2></a>
<p>All source code (including code snippets) is licensed under either of</p>
<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or
<a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or
<a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>)</li>
</ul>
<p>at your option.</p>
<p>The written prose contained within the book is licensed under the terms of the
Creative Commons CC-BY-SA v4.0 license (<a href="LICENSE-CC-BY-SA">LICENSE-CC-BY-SA</a> or
<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">https://creativecommons.org/licenses/by-sa/4.0/legalcode</a>).</p>
<a class="header" href="#contribution" id="contribution"><h3>Contribution</h3></a>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
licensed as above, without any additional terms or conditions.</p>
<a class="header" href="#rtfm-by-example" id="rtfm-by-example"><h1>RTFM by example</h1></a>
<p>This part of the book introduces the Real Time For the Masses (RTFM) framework
to new users by walking them through examples of increasing complexity.</p>
<p>All examples in this part of the book can be found in the GitHub <a href="https://github.com/japaric/cortex-m-rtfm">repository</a> of
the project, and most of the examples can be run on QEMU so no special hardware
is required to follow along.</p>
<p>To run the examples on your laptop / PC you'll need the <code>qemu-system-arm</code>
program. Check <a href="https://rust-embedded.github.io/book/intro/install.html">the embedded Rust book</a> for instructions on how to set up an
embedded development environment that includes QEMU.</p>
<a class="header" href="#the-app-attribute" id="the-app-attribute"><h1>The <code>app</code> attribute</h1></a>
<p>This is the smallest possible RTFM application:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/smallest.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

// panic-handler crate
extern crate panic_semihosting;

use rtfm::app;

#[app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {}
};

#}</code></pre></pre>
<p>All RTFM applications use the <a href="../../api/cortex_m_rtfm_macros/attr.app.html"><code>app</code></a> attribute (<code>#[app(..)]</code>). This attribute
must be applied to a <code>const</code> item that contains items. The <code>app</code> attribute has
a mandatory <code>device</code> argument that takes a <em>path</em> as a value. This path must
point to a <em>peripheral access crate</em> (PAC) generated using <a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a>
<strong>v0.14.x</strong>. The <code>app</code> attribute will expand into a suitable entry point so it's
not required to use the <a href="../../api/cortex_m_rt_macros/attr.entry.html"><code>cortex_m_rt::entry</code></a> attribute.</p>
<blockquote>
<p><strong>ASIDE</strong>: Some of you may be wondering why we are using a <code>const</code> item as a
module and not a proper <code>mod</code> item. The reason is that using attributes on
modules requires a feature gate, which requires a nightly toolchain. To make
RTFM work on stable we use the <code>const</code> item instead. When more parts of macros
1.2 are stabilized we'll move from a <code>const</code> item to a <code>mod</code> item and
eventually to a crate level attribute (<code>#![app]</code>).</p>
</blockquote>
<a class="header" href="#init" id="init"><h2><code>init</code></h2></a>
<p>Within the pseudo-module the <code>app</code> attribute expects to find an initialization
function marked with the <code>init</code> attribute. This function must have signature
<code>fn(init::Context) [-&gt; init::LateResources]</code>.</p>
<p>This initialization function will be the first part of the application to run.
The <code>init</code> function will run <em>with interrupts disabled</em> and has exclusive access
to Cortex-M and device specific peripherals through the <code>core</code> and <code>device</code>
variables fields of <code>init::Context</code>. Not all Cortex-M peripherals are available
in <code>core</code> because the RTFM runtime takes ownership of some of them -- for more
details see the <a href="../../api/rtfm/struct.Peripherals.html"><code>rtfm::Peripherals</code></a> struct.</p>
<p><code>static mut</code> variables declared at the beginning of <code>init</code> will be transformed
into <code>&amp;'static mut</code> references that are safe to access.</p>
<p>The example below shows the types of the <code>core</code> and <code>device</code> variables and
showcases safe access to a <code>static mut</code> variable.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/init.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(c: init::Context) {
        static mut X: u32 = 0;

        // Cortex-M peripherals
        let _core: rtfm::Peripherals = c.core;

        // Device specific peripherals
        let _device: lm3s6965::Peripherals = c.device;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        hprintln!(&quot;init&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }
};

#}</code></pre></pre>
<p>Running the example will print <code>init</code> to the console and then exit the QEMU
process.</p>
<pre><code class="language-console">$ cargo run --example init
init
</code></pre>
<a class="header" href="#idle" id="idle"><h2><code>idle</code></h2></a>
<p>A function marked with the <code>idle</code> attribute can optionally appear in the
pseudo-module. This function is used as the special <em>idle task</em> and must have
signature <code>fn(idle::Context) - &gt; !</code>.</p>
<p>When present, the runtime will execute the <code>idle</code> task after <code>init</code>. Unlike
<code>init</code>, <code>idle</code> will run <em>with interrupts enabled</em> and it's not allowed to return
so it runs forever.</p>
<p>When no <code>idle</code> function is declared, the runtime sets the <a href="https://developer.arm.com/products/architecture/cpu-architecture/m-profile/docs/100737/0100/power-management/sleep-mode/sleep-on-exit-bit">SLEEPONEXIT</a> bit and
then sends the microcontroller to sleep after running <code>init</code>.</p>
<p>Like in <code>init</code>, <code>static mut</code> variables will be transformed into <code>&amp;'static mut</code>
references that are safe to access.</p>
<p>The example below shows that <code>idle</code> runs after <code>init</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/idle.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        hprintln!(&quot;init&quot;).unwrap();
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        static mut X: u32 = 0;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        hprintln!(&quot;idle&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);

        loop {}
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example idle
init
idle
</code></pre>
<a class="header" href="#interrupt--exception" id="interrupt--exception"><h2><code>interrupt</code> / <code>exception</code></h2></a>
<p>Just like you would do with the <code>cortex-m-rt</code> crate you can use the <code>interrupt</code>
and <code>exception</code> attributes within the <code>app</code> pseudo-module to declare interrupt
and exception handlers. In RTFM, we refer to interrupt and exception handlers as
<em>hardware</em> tasks.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/interrupt.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        // Pends the UART0 interrupt but its handler won't run until *after*
        // `init` returns because interrupts are disabled
        rtfm::pend(Interrupt::UART0);

        hprintln!(&quot;init&quot;).unwrap();
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        // interrupts are enabled again; the `UART0` handler runs at this point

        hprintln!(&quot;idle&quot;).unwrap();

        rtfm::pend(Interrupt::UART0);

        debug::exit(debug::EXIT_SUCCESS);

        loop {}
    }

    #[interrupt]
    fn UART0(_: UART0::Context) {
        static mut TIMES: u32 = 0;

        // Safe access to local `static mut` variable
        *TIMES += 1;

        hprintln!(
            &quot;UART0 called {} time{}&quot;,
            *TIMES,
            if *TIMES &gt; 1 { &quot;s&quot; } else { &quot;&quot; }
        )
        .unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example interrupt
init
UART0 called 1 time
idle
UART0 called 2 times
</code></pre>
<p>So far all the RTFM applications we have seen look no different that the
applications one can write using only the <code>cortex-m-rt</code> crate. In the next
section we start introducing features unique to RTFM.</p>
<a class="header" href="#resources" id="resources"><h2>Resources</h2></a>
<p>One of the limitations of the attributes provided by the <code>cortex-m-rt</code> crate is
that sharing data (or peripherals) between interrupts, or between an interrupt
and the <code>entry</code> function, requires a <code>cortex_m::interrupt::Mutex</code>, which
<em>always</em> requires disabling <em>all</em> interrupts to access the data. Disabling all
the interrupts is not always required for memory safety but the compiler doesn't
have enough information to optimize the access to the shared data.</p>
<p>The <code>app</code> attribute has a full view of the application thus it can optimize
access to <code>static</code> variables. In RTFM we refer to the <code>static</code> variables
declared inside the <code>app</code> pseudo-module as <em>resources</em>. To access a resource the
context (<code>init</code>, <code>idle</code>, <code>interrupt</code> or <code>exception</code>) one must first declare the
resource in the <code>resources</code> argument of its attribute.</p>
<p>In the example below two interrupt handlers access the same resource. No <code>Mutex</code>
is required in this case because the two handlers run at the same priority and
no preemption is possible. The <code>SHARED</code> resource can only be accessed by these
two handlers.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/resource.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    // A resource
    static mut SHARED: u32 = 0;

    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::UART0);
        rtfm::pend(Interrupt::UART1);
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        debug::exit(debug::EXIT_SUCCESS);

        // error: `SHARED` can't be accessed from this context
        // SHARED += 1;

        loop {}
    }

    // `SHARED` can be access from this context
    #[interrupt(resources = [SHARED])]
    fn UART0(mut c: UART0::Context) {
        *c.resources.SHARED += 1;

        hprintln!(&quot;UART0: SHARED = {}&quot;, c.resources.SHARED).unwrap();
    }

    // `SHARED` can be access from this context
    #[interrupt(resources = [SHARED])]
    fn UART1(mut c: UART1::Context) {
        *c.resources.SHARED += 1;

        hprintln!(&quot;UART1: SHARED = {}&quot;, c.resources.SHARED).unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example resource
UART0: SHARED = 1
UART1: SHARED = 2
</code></pre>
<a class="header" href="#priorities" id="priorities"><h2>Priorities</h2></a>
<p>The priority of each handler can be declared in the <code>interrupt</code> and <code>exception</code>
attributes. It's not possible to set the priority in any other way because the
runtime takes ownership of the <code>NVIC</code> peripheral thus it's also not possible to
change the priority of a handler / task at runtime. Thanks to this restriction
the framework has knowledge about the <em>static</em> priorities of all interrupt and
exception handlers.</p>
<p>Interrupts and exceptions can have priorities in the range <code>1..=(1 &lt;&lt; NVIC_PRIO_BITS)</code> where <code>NVIC_PRIO_BITS</code> is a constant defined in the <code>device</code>
crate. The <code>idle</code> task has a priority of <code>0</code>, the lowest priority.</p>
<p>Resources that are shared between handlers that run at different priorities
require critical sections for memory safety. The framework ensures that critical
sections are used but <em>only where required</em>: for example, no critical section is
required by the highest priority handler that has access to the resource.</p>
<p>The critical section API provided by the RTFM framework (see <a href="../../api/rtfm/trait.Mutex.html"><code>Mutex</code></a>) is
based on dynamic priorities rather than on disabling interrupts. The consequence
is that these critical sections will prevent <em>some</em> handlers, including all the
ones that contend for the resource, from <em>starting</em> but will let higher priority
handlers, that don't contend for the resource, run.</p>
<p>In the example below we have three interrupt handlers with priorities ranging
from one to three. The two handlers with the lower priorities contend for the
<code>SHARED</code> resource. The lowest priority handler needs to <a href="../../api/rtfm/trait.Mutex.html#method.lock"><code>lock</code></a> the
<code>SHARED</code> resource to access its data, whereas the mid priority handler can
directly access its data. The highest priority handler is free to preempt
the critical section created by the lowest priority handler.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/lock.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: u32 = 0;

    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::GPIOA);
    }

    // when omitted priority is assumed to be `1`
    #[interrupt(resources = [SHARED])]
    fn GPIOA(mut c: GPIOA::Context) {
        hprintln!(&quot;A&quot;).unwrap();

        // the lower priority task requires a critical section to access the data
        c.resources.SHARED.lock(|shared| {
            // data can only be modified within this critical section (closure)
            *shared += 1;

            // GPIOB will *not* run right now due to the critical section
            rtfm::pend(Interrupt::GPIOB);

            hprintln!(&quot;B - SHARED = {}&quot;, *shared).unwrap();

            // GPIOC does not contend for `SHARED` so it's allowed to run now
            rtfm::pend(Interrupt::GPIOC);
        });

        // critical section is over: GPIOB can now start

        hprintln!(&quot;E&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[interrupt(priority = 2, resources = [SHARED])]
    fn GPIOB(mut c: GPIOB::Context) {
        // the higher priority task does *not* need a critical section
        *c.resources.SHARED += 1;

        hprintln!(&quot;D - SHARED = {}&quot;, *c.resources.SHARED).unwrap();
    }

    #[interrupt(priority = 3)]
    fn GPIOC(_: GPIOC::Context) {
        hprintln!(&quot;C&quot;).unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example lock
A
B - SHARED = 1
C
D - SHARED = 2
E
</code></pre>
<p>One more note about priorities: choosing a priority higher than what the device
supports (that is <code>1 &lt;&lt; NVIC_PRIO_BITS</code>) will result in a compile error. Due to
limitations in the language the error message is currently far from helpful: it
will say something along the lines of &quot;evaluation of constant value failed&quot; and
the span of the error will <em>not</em> point out to the problematic interrupt value --
we are sorry about this!</p>
<a class="header" href="#late-resources" id="late-resources"><h2>Late resources</h2></a>
<p>Unlike normal <code>static</code> variables, which need to be assigned an initial value
when declared, resources can be initialized at runtime. We refer to these
runtime initialized resources as <em>late resources</em>. Late resources are useful for
<em>moving</em> (as in transferring ownership) peripherals initialized in <code>init</code> into
interrupt and exception handlers.</p>
<p>Late resources are declared like normal resources but that are given an initial
value of <code>()</code> (the unit value). <code>init</code> must return the initial values of all
late resources packed in a <code>struct</code> of type <code>init::LateResources</code>.</p>
<p>The example below uses late resources to stablish a lockless, one-way channel
between the <code>UART0</code> interrupt handler and the <code>idle</code> function. A single producer
single consumer <a href="../../api/heapless/spsc/struct.Queue.html"><code>Queue</code></a> is used as the channel. The queue is split into
consumer and producer end points in <code>init</code> and then each end point is stored
in a different resource; <code>UART0</code> owns the producer resource and <code>idle</code> owns
the consumer resource.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/late.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use heapless::{
    consts::*,
    spsc::{Consumer, Producer, Queue},
};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    // Late resources
    static mut P: Producer&lt;'static, u32, U4&gt; = ();
    static mut C: Consumer&lt;'static, u32, U4&gt; = ();

    #[init]
    fn init(_: init::Context) -&gt; init::LateResources {
        // NOTE: we use `Option` here to work around the lack of
        // a stable `const` constructor
        static mut Q: Option&lt;Queue&lt;u32, U4&gt;&gt; = None;

        *Q = Some(Queue::new());
        let (p, c) = Q.as_mut().unwrap().split();

        // Initialization of late resources
        init::LateResources { P: p, C: c }
    }

    #[idle(resources = [C])]
    fn idle(c: idle::Context) -&gt; ! {
        loop {
            if let Some(byte) = c.resources.C.dequeue() {
                hprintln!(&quot;received message: {}&quot;, byte).unwrap();

                debug::exit(debug::EXIT_SUCCESS);
            } else {
                rtfm::pend(Interrupt::UART0);
            }
        }
    }

    #[interrupt(resources = [P])]
    fn UART0(c: UART0::Context) {
        c.resources.P.enqueue(42).unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example late
received message: 42
</code></pre>
<a class="header" href="#static-resources" id="static-resources"><h2><code>static</code> resources</h2></a>
<p><code>static</code> variables can also be used as resources. Tasks can only get <code>&amp;</code>
(shared) references to these resources but locks are never required to access
their data. You can think of <code>static</code> resources as plain <code>static</code> variables that
can be initialized at runtime and have better scoping rules: you can control
which tasks can access the variable, instead of the variable being visible to
all the functions in the scope it was declared in.</p>
<p>In the example below a key is loaded (or created) at runtime and then used from
two tasks that run at different priorities.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/static.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static KEY: u32 = ();

    #[init]
    fn init(_: init::Context) -&gt; init::LateResources {
        rtfm::pend(Interrupt::UART0);
        rtfm::pend(Interrupt::UART1);

        init::LateResources { KEY: 0xdeadbeef }
    }

    #[interrupt(resources = [KEY])]
    fn UART0(c: UART0::Context) {
        hprintln!(&quot;UART0(KEY = {:#x})&quot;, c.resources.KEY).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[interrupt(priority = 2, resources = [KEY])]
    fn UART1(c: UART1::Context) {
        hprintln!(&quot;UART1(KEY = {:#x})&quot;, c.resources.KEY).unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example static
UART1(KEY = 0xdeadbeef)
UART0(KEY = 0xdeadbeef)
</code></pre>
<a class="header" href="#software-tasks" id="software-tasks"><h1>Software tasks</h1></a>
<p>RTFM treats interrupt and exception handlers as <em>hardware</em> tasks. Hardware tasks
are invoked by the hardware in response to events, like pressing a button. RTFM
also supports <em>software</em> tasks which can be spawned by the software from any
execution context.</p>
<p>Software tasks can also be assigned priorities and are dispatched from interrupt
handlers. RTFM requires that free interrupts are declared in an <code>extern</code> block
when using software tasks; these free interrupts will be used to dispatch the
software tasks. An advantage of software tasks over hardware tasks is that many
tasks can be mapped to a single interrupt handler.</p>
<p>Software tasks are declared by applying the <code>task</code> attribute to functions. To be
able to spawn a software task the name of the task must appear in the <code>spawn</code>
argument of the context attribute (<code>init</code>, <code>idle</code>, <code>interrupt</code>, etc.).</p>
<p>The example below showcases three software tasks that run at 2 different
priorities. The three tasks map to 2 interrupts handlers.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/task.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(c: init::Context) {
        c.spawn.foo().unwrap();
    }

    #[task(spawn = [bar, baz])]
    fn foo(c: foo::Context) {
        hprintln!(&quot;foo&quot;).unwrap();

        // spawns `bar` onto the task scheduler
        // `foo` and `bar` have the same priority so `bar` will not run until
        // after `foo` terminates
        c.spawn.bar().unwrap();

        // spawns `baz` onto the task scheduler
        // `baz` has higher priority than `foo` so it immediately preempts `foo`
        c.spawn.baz().unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(priority = 2)]
    fn baz(_: baz::Context) {
        hprintln!(&quot;baz&quot;).unwrap();
    }

    // Interrupt handlers used to dispatch software tasks
    extern &quot;C&quot; {
        fn UART0();
        fn UART1();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example task
foo
baz
bar
</code></pre>
<a class="header" href="#message-passing" id="message-passing"><h2>Message passing</h2></a>
<p>The other advantage of software tasks is that messages can be passed to these
tasks when spawning them. The type of the message payload must be specified in
the signature of the task handler.</p>
<p>The example below showcases three tasks, two of them expect a message.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/message.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(c: init::Context) {
        c.spawn.foo(/* no message */).unwrap();
    }

    #[task(spawn = [bar])]
    fn foo(c: foo::Context) {
        static mut COUNT: u32 = 0;

        hprintln!(&quot;foo&quot;).unwrap();

        c.spawn.bar(*COUNT).unwrap();
        *COUNT += 1;
    }

    #[task(spawn = [baz])]
    fn bar(c: bar::Context, x: u32) {
        hprintln!(&quot;bar({})&quot;, x).unwrap();

        c.spawn.baz(x + 1, x + 2).unwrap();
    }

    #[task(spawn = [foo])]
    fn baz(c: baz::Context, x: u32, y: u32) {
        hprintln!(&quot;baz({}, {})&quot;, x, y).unwrap();

        if x + y &gt; 4 {
            debug::exit(debug::EXIT_SUCCESS);
        }

        c.spawn.foo().unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example message
foo
bar(0)
baz(1, 2)
foo
bar(1)
baz(2, 3)
</code></pre>
<a class="header" href="#capacity" id="capacity"><h2>Capacity</h2></a>
<p>Task dispatchers do <em>not</em> use any dynamic memory allocation. The memory required
to store messages is statically reserved. The framework will reserve enough
space for every context to be able to spawn each task at most once. This is a
sensible default but the &quot;inbox&quot; capacity of each task can be controlled using
the <code>capacity</code> argument of the <code>task</code> attribute.</p>
<p>The example below sets the capacity of the software task <code>foo</code> to 4. If the
capacity is not specified then the second <code>spawn.foo</code> call in <code>UART0</code> would
fail.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/capacity.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::UART0);
    }

    #[interrupt(spawn = [foo, bar])]
    fn UART0(c: UART0::Context) {
        c.spawn.foo(0).unwrap();
        c.spawn.foo(1).unwrap();
        c.spawn.foo(2).unwrap();
        c.spawn.foo(3).unwrap();

        c.spawn.bar().unwrap();
    }

    #[task(capacity = 4)]
    fn foo(_: foo::Context, x: u32) {
        hprintln!(&quot;foo({})&quot;, x).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    // Interrupt handlers used to dispatch software tasks
    extern &quot;C&quot; {
        fn UART1();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example capacity
foo(0)
foo(1)
foo(2)
foo(3)
bar
</code></pre>
<a class="header" href="#timer-queue" id="timer-queue"><h1>Timer queue</h1></a>
<p>When the <code>timer-queue</code> feature is enabled the RTFM framework includes a <em>global
timer queue</em> that applications can use to <em>schedule</em> software tasks to run at
some time in the future.</p>
<blockquote>
<p><strong>NOTE</strong>: The timer-queue feature can't be enabled when the target is
<code>thumbv6m-none-eabi</code> because there's no timer queue support for ARMv6-M. This
may change in the future.</p>
</blockquote>
<blockquote>
<p><strong>NOTE</strong>: When the <code>timer-queue</code> feature is enabled you will <em>not</em> be able to
use the <code>SysTick</code> exception as a hardware task because the runtime uses it to
implement the global timer queue.</p>
</blockquote>
<p>To be able to schedule a software task the name of the task must appear in the
<code>schedule</code> argument of the context attribute. When scheduling a task the
<a href="../../api/rtfm/struct.Instant.html"><code>Instant</code></a> at which the task should be executed must be passed as the first
argument of the <code>schedule</code> invocation.</p>
<p>The RTFM runtime includes a monotonic, non-decreasing, 32-bit timer which can be
queried using the <code>Instant::now</code> constructor. A <a href="../../api/rtfm/struct.Duration.html"><code>Duration</code></a> can be added to
<code>Instant::now()</code> to obtain an <code>Instant</code> into the future. The monotonic timer is
disabled while <code>init</code> runs so <code>Instant::now()</code> always returns the value
<code>Instant(0 /* clock cycles */)</code>; the timer is enabled right before the
interrupts are re-enabled and <code>idle</code> is executed.</p>
<p>The example below schedules two tasks from <code>init</code>: <code>foo</code> and <code>bar</code>. <code>foo</code> is
scheduled to run 8 million clock cycles in the future. Next, <code>bar</code> is scheduled
to run 4 million clock cycles in the future. <code>bar</code> runs before <code>foo</code> since it
was scheduled to run first.</p>
<blockquote>
<p><strong>IMPORTANT</strong>: The examples that use the <code>schedule</code> API or the <code>Instant</code>
abstraction will <strong>not</strong> properly work on QEMU because the Cortex-M cycle
counter functionality has not been implemented in <code>qemu-system-arm</code>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/schedule.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::hprintln;
use rtfm::Instant;

// NOTE: does NOT work on QEMU!
#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(schedule = [foo, bar])]
    fn init(c: init::Context) {
        let now = Instant::now();

        hprintln!(&quot;init @ {:?}&quot;, now).unwrap();

        // Schedule `foo` to run 8e6 cycles (clock cycles) in the future
        c.schedule.foo(now + 8_000_000.cycles()).unwrap();

        // Schedule `bar` to run 4e6 cycles in the future
        c.schedule.bar(now + 4_000_000.cycles()).unwrap();
    }

    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo  @ {:?}&quot;, Instant::now()).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar  @ {:?}&quot;, Instant::now()).unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};

#}</code></pre></pre>
<p>Running the program on real hardware produces the following output in the console:</p>
<pre><code class="language-text">init @ Instant(0)
bar  @ Instant(4000236)
foo  @ Instant(8000173)
</code></pre>
<a class="header" href="#periodic-tasks" id="periodic-tasks"><h2>Periodic tasks</h2></a>
<p>Software tasks have access to the <code>Instant</code> at which they were scheduled to run
through the <code>scheduled</code> variable. This information and the <code>schedule</code> API can be
used to implement periodic tasks as shown in the example below.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/periodic.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::hprintln;
use rtfm::Instant;

const PERIOD: u32 = 8_000_000;

// NOTE: does NOT work on QEMU!
#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(schedule = [foo])]
    fn init(c: init::Context) {
        c.schedule.foo(Instant::now() + PERIOD.cycles()).unwrap();
    }

    #[task(schedule = [foo])]
    fn foo(c: foo::Context) {
        let now = Instant::now();
        hprintln!(&quot;foo(scheduled = {:?}, now = {:?})&quot;, c.scheduled, now).unwrap();

        c.schedule.foo(c.scheduled + PERIOD.cycles()).unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};

#}</code></pre></pre>
<p>This is the output produced by the example. Note that there is zero drift /
jitter even though <code>schedule.foo</code> was invoked at the <em>end</em> of <code>foo</code>. Using
<code>Instant::now</code> instead of <code>scheduled</code> would have resulted in drift / jitter.</p>
<pre><code class="language-text">foo(scheduled = Instant(8000000), now = Instant(8000196))
foo(scheduled = Instant(16000000), now = Instant(16000196))
foo(scheduled = Instant(24000000), now = Instant(24000196))
</code></pre>
<a class="header" href="#baseline" id="baseline"><h2>Baseline</h2></a>
<p>For the tasks scheduled from <code>init</code> we have exact information about their
<code>scheduled</code> time. For hardware tasks there's no <code>scheduled</code> time because these
tasks are asynchronous in nature. For hardware tasks the runtime provides a
<code>start</code> time, which indicates the time at which the task handler started
executing.</p>
<p>Note that <code>start</code> is <strong>not</strong> equal to the arrival time of the event that fired
the task. Depending on the priority of the task and the load of the system the
<code>start</code> time could be very far off from the event arrival time.</p>
<p>What do you think will be the value of <code>scheduled</code> for software tasks that are
<em>spawned</em> instead of scheduled? The answer is that spawned tasks inherit the
<em>baseline</em> time of the context that spawned it. The baseline of hardware tasks
is <code>start</code>, the baseline of software tasks is <code>scheduled</code> and the baseline of
<code>init</code> is <code>start = Instant(0)</code>. <code>idle</code> doesn't really have a baseline but tasks
spawned from it will use <code>Instant::now()</code> as their baseline time.</p>
<p>The example below showcases the different meanings of the <em>baseline</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/baseline.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

// NOTE: does NOT properly work on QEMU
#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [foo])]
    fn init(c: init::Context) {
        hprintln!(&quot;init(baseline = {:?})&quot;, c.start).unwrap();

        // `foo` inherits the baseline of `init`: `Instant(0)`
        c.spawn.foo().unwrap();
    }

    #[task(schedule = [foo])]
    fn foo(c: foo::Context) {
        static mut ONCE: bool = true;

        hprintln!(&quot;foo(baseline = {:?})&quot;, c.scheduled).unwrap();

        if *ONCE {
            *ONCE = false;

            rtfm::pend(Interrupt::UART0);
        } else {
            debug::exit(debug::EXIT_SUCCESS);
        }
    }

    #[interrupt(spawn = [foo])]
    fn UART0(c: UART0::Context) {
        hprintln!(&quot;UART0(baseline = {:?})&quot;, c.start).unwrap();

        // `foo` inherits the baseline of `UART0`: its `start` time
        c.spawn.foo().unwrap();
    }

    extern &quot;C&quot; {
        fn UART1();
    }
};

#}</code></pre></pre>
<p>Running the program on real hardware produces the following output in the console:</p>
<pre><code class="language-text">init(baseline = Instant(0))
foo(baseline = Instant(0))
UART0(baseline = Instant(904))
foo(baseline = Instant(904))
</code></pre>
<a class="header" href="#types-send-and-sync" id="types-send-and-sync"><h1>Types, Send and Sync</h1></a>
<p>The <code>app</code> attribute injects a context, a collection of variables, into every
function. All these variables have predictable, non-anonymous types so you can
write plain functions that take them as arguments.</p>
<p>The API reference specifies how these types are generated from the input. You
can also generate documentation for you binary crate (<code>cargo doc --bin &lt;name&gt;</code>);
in the documentation you'll find <code>Context</code> structs (e.g. <code>init::Context</code> and
<code>idle::Context</code>).</p>
<p>The example below shows the different types generates by the <code>app</code> attribute.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/types.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::debug;
use rtfm::{Exclusive, Instant};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: u32 = 0;

    #[init(schedule = [foo], spawn = [foo])]
    fn init(c: init::Context) {
        let _: Instant = c.start;
        let _: rtfm::Peripherals = c.core;
        let _: lm3s6965::Peripherals = c.device;
        let _: init::Schedule = c.schedule;
        let _: init::Spawn = c.spawn;

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[exception(schedule = [foo], spawn = [foo])]
    fn SVCall(c: SVCall::Context) {
        let _: Instant = c.start;
        let _: SVCall::Schedule = c.schedule;
        let _: SVCall::Spawn = c.spawn;
    }

    #[interrupt(resources = [SHARED], schedule = [foo], spawn = [foo])]
    fn UART0(c: UART0::Context) {
        let _: Instant = c.start;
        let _: resources::SHARED = c.resources.SHARED;
        let _: UART0::Schedule = c.schedule;
        let _: UART0::Spawn = c.spawn;
    }

    #[task(priority = 2, resources = [SHARED], schedule = [foo], spawn = [foo])]
    fn foo(c: foo::Context) {
        let _: Instant = c.scheduled;
        let _: Exclusive&lt;u32&gt; = c.resources.SHARED;
        let _: foo::Resources = c.resources;
        let _: foo::Schedule = c.schedule;
        let _: foo::Spawn = c.spawn;
    }

    extern &quot;C&quot; {
        fn UART1();
    }
};

#}</code></pre></pre>
<a class="header" href="#send" id="send"><h2><code>Send</code></h2></a>
<p><a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a> is a marker trait for &quot;types that can be transferred across thread
boundaries&quot;, according to its definition in <code>core</code>. In the context of RTFM the
<code>Send</code> trait is only required where it's possible to transfer a value between
tasks that run at <em>different</em> priorities. This occurs in a few places: in message
passing, in shared <code>static mut</code> resources and in the initialization of late
resources.</p>
<p>The <code>app</code> attribute will enforce that <code>Send</code> is implemented where required so
you don't need to worry much about it. It's more important to know where you do
<em>not</em> need the <code>Send</code> trait: on types that are transferred between tasks that
run at the <em>same</em> priority. This occurs in two places: in message passing and in
shared <code>static mut</code> resources.</p>
<p>The example below shows where a type that doesn't implement <code>Send</code> can be used.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! `examples/not-send.rs`

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_halt;

use core::marker::PhantomData;

use cortex_m_semihosting::debug;
use rtfm::app;

pub struct NotSend {
    _0: PhantomData&lt;*const ()&gt;,
}

#[app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: Option&lt;NotSend&gt; = None;

    #[init(spawn = [baz, quux])]
    fn init(c: init::Context) {
        c.spawn.baz().unwrap();
        c.spawn.quux().unwrap();
    }

    #[task(spawn = [bar])]
    fn foo(c: foo::Context) {
        // scenario 1: message passed to task that runs at the same priority
        c.spawn.bar(NotSend { _0: PhantomData }).ok();
    }

    #[task]
    fn bar(_: bar::Context, _x: NotSend) {
        // scenario 1
    }

    #[task(priority = 2, resources = [SHARED])]
    fn baz(mut c: baz::Context) {
        // scenario 2: resource shared between tasks that run at the same priority
        *c.resources.SHARED = Some(NotSend { _0: PhantomData });
    }

    #[task(priority = 2, resources = [SHARED])]
    fn quux(mut c: quux::Context) {
        // scenario 2
        let _not_send = c.resources.SHARED.take().unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    extern &quot;C&quot; {
        fn UART0();
        fn UART1();
    }
};

#}</code></pre></pre>
<p>It's important to note that late initialization of resources is effectively a
send operation where the initial value is sent from <code>idle</code>, which has the lowest
priority of <code>0</code>, to a task with will run with a priority greater than or equal
to <code>1</code>. Thus all late resources need to implement the <code>Send</code> trait.</p>
<p>Sharing a resource with <code>init</code> can be used to implement late initialization, see
example below. For that reason, resources shared with <code>init</code> must also implement
the <code>Send</code> trait.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! `examples/shared-with-init.rs`

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_halt;

use cortex_m_semihosting::debug;
use lm3s6965::Interrupt;
use rtfm::app;

pub struct MustBeSend;

#[app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: Option&lt;MustBeSend&gt; = None;

    #[init(resources = [SHARED])]
    fn init(c: init::Context) {
        // this `message` will be sent to task `UART0`
        let message = MustBeSend;
        *c.resources.SHARED = Some(message);

        rtfm::pend(Interrupt::UART0);
    }

    #[interrupt(resources = [SHARED])]
    fn UART0(c: UART0::Context) {
        if let Some(message) = c.resources.SHARED.take() {
            // `message` has been received
            drop(message);

            debug::exit(debug::EXIT_SUCCESS);
        }
    }
};

#}</code></pre></pre>
<a class="header" href="#sync" id="sync"><h2><code>Sync</code></h2></a>
<p>Similarly, <a href="https://doc.rust-lang.org/core/marker/trait.Sync.html"><code>Sync</code></a> is a marker trait for &quot;types for which it is safe to share
references between threads&quot;, according to its definition in <code>core</code>. In the
context of RTFM the <code>Sync</code> trait is only required where it's possible for two,
or more, tasks that run at different priority to hold a shared reference to a
resource. This only occurs with shared <code>static</code> resources.</p>
<p>The <code>app</code> attribute will enforce that <code>Sync</code> is implemented where required but
it's important to know where the <code>Sync</code> bound is not required: in <code>static</code>
resources shared between tasks that run at the <em>same</em> priority.</p>
<p>The example below shows where a type that doesn't implement <code>Sync</code> can be used.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! `examples/not-sync.rs`

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_halt;

use core::marker::PhantomData;

use cortex_m_semihosting::debug;

pub struct NotSync {
    _0: PhantomData&lt;*const ()&gt;,
}

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static SHARED: NotSync = NotSync { _0: PhantomData };

    #[init]
    fn init(_: init::Context) {
        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(resources = [SHARED])]
    fn foo(c: foo::Context) {
        let _: &amp;NotSync = c.resources.SHARED;
    }

    #[task(resources = [SHARED])]
    fn bar(c: bar::Context) {
        let _: &amp;NotSync = c.resources.SHARED;
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};

#}</code></pre></pre>
<a class="header" href="#starting-a-new-project" id="starting-a-new-project"><h1>Starting a new project</h1></a>
<p>Now that you have learned about the main features of the RTFM framework you can
try it out on your hardware by following these instructions.</p>
<ol>
<li>Instantiate the <a href="https://github.com/rust-embedded/cortex-m-quickstart#cortex-m-quickstart"><code>cortex-m-quickstart</code></a> template.</li>
</ol>
<pre><code class="language-console">$ # for example using `cargo-generate`
$ cargo generate \
    --git https://github.com/rust-embedded/cortex-m-quickstart \
    --name app

$ # follow the rest of the instructions
</code></pre>
<ol start="2">
<li>Add a peripheral access crate (PAC) that was generated using <a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a>
<strong>v0.14.x</strong>, or a board support crate that depends on one such PAC as a
dependency. Make sure that the <code>rt</code> feature of the crate is enabled.</li>
</ol>
<p>In this example, I'll use the <a href="https://crates.io/crates/lm3s6965"><code>lm3s6965</code></a> device crate. This device crate
doesn't have an <code>rt</code> Cargo feature; that feature is always enabled.</p>
<p>This device crate provides a linker script with the memory layout of the target
device so <code>memory.x</code> and <code>build.rs</code> need to be removed.</p>
<pre><code class="language-console">$ cargo add lm3s6965 --vers 0.1.3

$ rm memory.x build.rs
</code></pre>
<ol start="3">
<li>Add the <code>cortex-m-rtfm</code> crate as a dependency and, if you need it, enable the
<code>timer-queue</code> feature.</li>
</ol>
<pre><code class="language-console">$ cargo add cortex-m-rtfm --allow-prerelease
</code></pre>
<ol start="4">
<li>Write your RTFM application.</li>
</ol>
<p>Here I'll use the <code>init</code> example from the <code>cortex-m-rtfm</code> crate.</p>
<pre><code class="language-console">$ curl \
    -L https://github.com/japaric/cortex-m-rtfm/raw/v0.5.0-alpha.1/examples/init.rs \
    &gt; src/main.rs
</code></pre>
<p>That example depends on the <code>panic-semihosting</code> crate:</p>
<pre><code class="language-console">$ cargo add panic-semihosting
</code></pre>
<ol start="5">
<li>Build it, flash it and run it.</li>
</ol>
<pre><code class="language-console">$ # NOTE: I have uncommented the `runner` option in `.cargo/config`
$ cargo run
init
</code></pre>
<a class="header" href="#tips--tricks" id="tips--tricks"><h1>Tips &amp; tricks</h1></a>
<a class="header" href="#generics" id="generics"><h2>Generics</h2></a>
<p>Resources shared between two or more tasks implement the <code>Mutex</code> trait in <em>all</em>
contexts, even on those where a critical section is not required to access the
data. This lets you easily write generic code that operates on resources and can
be called from different tasks. Here's one such example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/generics.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;
use rtfm::Mutex;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    static mut SHARED: u32 = 0;

    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::UART0);
        rtfm::pend(Interrupt::UART1);
    }

    #[interrupt(resources = [SHARED])]
    fn UART0(c: UART0::Context) {
        static mut STATE: u32 = 0;

        hprintln!(&quot;UART0(STATE = {})&quot;, *STATE).unwrap();

        advance(STATE, c.resources.SHARED);

        rtfm::pend(Interrupt::UART1);

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[interrupt(priority = 2, resources = [SHARED])]
    fn UART1(mut c: UART1::Context) {
        static mut STATE: u32 = 0;

        hprintln!(&quot;UART1(STATE = {})&quot;, *STATE).unwrap();

        // just to show that `SHARED` can be accessed directly and ..
        *c.resources.SHARED += 0;
        // .. also through a (no-op) `lock`
        c.resources.SHARED.lock(|shared| *shared += 0);

        advance(STATE, c.resources.SHARED);
    }
};

fn advance(state: &amp;mut u32, mut shared: impl Mutex&lt;T = u32&gt;) {
    *state += 1;

    let (old, new) = shared.lock(|shared| {
        let old = *shared;
        *shared += *state;
        (old, *shared)
    });

    hprintln!(&quot;SHARED: {} -&gt; {}&quot;, old, new).unwrap();
}

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example generics
UART1(STATE = 0)
SHARED: 0 -&gt; 1
UART0(STATE = 0)
SHARED: 1 -&gt; 2
UART1(STATE = 1)
SHARED: 2 -&gt; 4
</code></pre>
<p>This also lets you change the static priorities of tasks without having to
rewrite code. If you consistently use <code>lock</code>s to access the data behind shared
resources then your code will continue to compile when you change the priority
of tasks.</p>
<a class="header" href="#conditional-compilation" id="conditional-compilation"><h2>Conditional compilation</h2></a>
<p>You can use conditional compilation (<code>#[cfg]</code>) on resources (<code>static [mut]</code>
items) and tasks (<code>fn</code> items). The effect of using <code>#[cfg]</code> attributes is that
the resource / task will <em>not</em> be available through the corresponding <code>Context</code>
<code>struct</code> if the condition doesn't hold.</p>
<p>The example below logs a message whenever the <code>foo</code> task is spawned, but only if
the program has been compiled using the <code>dev</code> profile.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/cfg.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

#[cfg(debug_assertions)]
use cortex_m_semihosting::hprintln;

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[cfg(debug_assertions)] // &lt;- `true` when using the `dev` profile
    static mut COUNT: u32 = 0;

    #[init]
    fn init(_: init::Context) {
        // ..
    }

    #[task(priority = 3, resources = [COUNT], spawn = [log])]
    fn foo(c: foo::Context) {
        #[cfg(debug_assertions)]
        {
            *c.resources.COUNT += 1;

            c.spawn.log(*c.resources.COUNT).ok();
        }

        // this wouldn't compile in `release` mode
        // *resources.COUNT += 1;

        // ..
    }

    #[cfg(debug_assertions)]
    #[task]
    fn log(_: log::Context, n: u32) {
        hprintln!(
            &quot;foo has been called {} time{}&quot;,
            n,
            if n == 1 { &quot;&quot; } else { &quot;s&quot; }
        )
        .ok();
    }

    extern &quot;C&quot; {
        fn UART0();
        fn UART1();
    }
};

#}</code></pre></pre>
<a class="header" href="#running-tasks-from-ram" id="running-tasks-from-ram"><h2>Running tasks from RAM</h2></a>
<p>The main goal of moving the specification of RTFM applications to attributes in
RTFM v0.4.0 was to allow inter-operation with other attributes. For example, the
<code>link_section</code> attribute can be applied to tasks to place them in RAM; this can
improve performance in some cases.</p>
<blockquote>
<p><strong>IMPORTANT</strong>: In general, the <code>link_section</code>, <code>export_name</code> and <code>no_mangle</code>
attributes are very powerful but also easy to misuse. Incorrectly using any of
these attributes can cause undefined behavior; you should always prefer to use
safe, higher level attributes around them like <code>cortex-m-rt</code>'s <code>interrupt</code> and
<code>exception</code> attributes.</p>
<p>In the particular case of RAM functions there's no
safe abstraction for it in <code>cortex-m-rt</code> v0.6.5 but there's an <a href="https://github.com/rust-embedded/cortex-m-rt/pull/100">RFC</a> for
adding a <code>ramfunc</code> attribute in a future release.</p>
</blockquote>
<p>The example below shows how to place the higher priority task, <code>bar</code>, in RAM.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/ramfunc.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};

#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init(spawn = [bar])]
    fn init(c: init::Context) {
        c.spawn.bar().unwrap();
    }

    #[inline(never)]
    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    // run this task from RAM
    #[inline(never)]
    #[link_section = &quot;.data.bar&quot;]
    #[task(priority = 2, spawn = [foo])]
    fn bar(c: bar::Context) {
        c.spawn.foo().unwrap();
    }

    extern &quot;C&quot; {
        fn UART0();

        // run the task dispatcher from RAM
        #[link_section = &quot;.data.UART1&quot;]
        fn UART1();
    }
};

#}</code></pre></pre>
<p>Running this program produces the expected output.</p>
<pre><code class="language-console">$ cargo run --example ramfunc
foo
</code></pre>
<p>One can look at the output of <code>cargo-nm</code> to confirm that <code>bar</code> ended in RAM
(<code>0x2000_0000</code>), whereas <code>foo</code> ended in Flash (<code>0x0000_0000</code>).</p>
<pre><code class="language-console">$ cargo nm --example ramfunc --release | grep ' foo::'
20000100 B foo::FREE_QUEUE::ujkptet2nfdw5t20
200000dc B foo::INPUTS::thvubs85b91dg365
000002c6 T foo::sidaht420cg1mcm8
</code></pre>
<pre><code class="language-console">$ cargo nm --example ramfunc --release | grep ' bar::'
20000100 B bar::FREE_QUEUE::lk14244m263eivix
200000dc B bar::INPUTS::mi89534s44r1mnj1
20000000 T bar::ns9009yhw2dc2y25
</code></pre>
<a class="header" href="#binds" id="binds"><h2><code>binds</code></h2></a>
<p>You can give hardware tasks more task-like names using the <code>binds</code> argument: you
name the function as you wish and specify the name of the interrupt / exception
in the <code>binds</code> argument. Types like <code>Spawn</code> will be placed in a module named
after the function, not the interrupt / exception. Example below:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/binds.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use lm3s6965::Interrupt;

// `examples/interrupt.rs` rewritten to use `binds`
#[rtfm::app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        rtfm::pend(Interrupt::UART0);

        hprintln!(&quot;init&quot;).unwrap();
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        hprintln!(&quot;idle&quot;).unwrap();

        rtfm::pend(Interrupt::UART0);

        debug::exit(debug::EXIT_SUCCESS);

        loop {}
    }

    #[interrupt(binds = UART0)]
    fn foo(_: foo::Context) {
        static mut TIMES: u32 = 0;

        *TIMES += 1;

        hprintln!(
            &quot;foo called {} time{}&quot;,
            *TIMES,
            if *TIMES &gt; 1 { &quot;s&quot; } else { &quot;&quot; }
        )
        .unwrap();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example binds
init
foo called 1 time
idle
foo called 2 times
</code></pre>
<a class="header" href="#indirection-for-faster-message-passing" id="indirection-for-faster-message-passing"><h2>Indirection for faster message passing</h2></a>
<p>Message passing always involves copying the payload from the sender into a
static variable and then from the static variable into the receiver. Thus
sending a large buffer, like a <code>[u8; 128]</code>, as a message involves two expensive
<code>memcpy</code>s. To minimize the message passing overhead one can use indirection:
instead of sending the buffer by value, one can send an owning pointer into the
buffer.</p>
<p>One can use a global allocator to achieve indirection (<code>alloc::Box</code>,
<code>alloc::Rc</code>, etc.), which requires using the nightly channel as of Rust v1.34.0,
or one can use a statically allocated memory pool like <a href="https://docs.rs/heapless/0.4.3/heapless/pool/index.html"><code>heapless::Pool</code></a>.</p>
<p>Here's an example where <code>heapless::Pool</code> is used to &quot;box&quot; buffers of 128 bytes.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! examples/pool.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_semihosting::{debug, hprintln};
use heapless::{
    pool,
    pool::singleton::{Box, Pool},
};
use lm3s6965::Interrupt;
use rtfm::app;

// Declare a pool of 128-byte memory blocks
pool!(P: [u8; 128]);

#[app(device = lm3s6965)]
const APP: () = {
    #[init]
    fn init(_: init::Context) {
        static mut MEMORY: [u8; 512] = [0; 512];

        // Increase the capacity of the memory pool by ~4
        P::grow(MEMORY);

        rtfm::pend(Interrupt::I2C0);
    }

    #[interrupt(priority = 2, spawn = [foo, bar])]
    fn I2C0(c: I2C0::Context) {
        // claim a memory block, leave it uninitialized and ..
        let x = P::alloc().unwrap().freeze();

        // .. send it to the `foo` task
        c.spawn.foo(x).ok().unwrap();

        // send another block to the task `bar`
        c.spawn.bar(P::alloc().unwrap().freeze()).ok().unwrap();
    }

    #[task]
    fn foo(_: foo::Context, x: Box&lt;P&gt;) {
        hprintln!(&quot;foo({:?})&quot;, x.as_ptr()).unwrap();

        // explicitly return the block to the pool
        drop(x);

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(priority = 2)]
    fn bar(_: bar::Context, x: Box&lt;P&gt;) {
        hprintln!(&quot;bar({:?})&quot;, x.as_ptr()).unwrap();

        // this is done automatically so we can omit the call to `drop`
        // drop(x);
    }

    extern &quot;C&quot; {
        fn UART0();
        fn UART1();
    }
};

#}</code></pre></pre>
<pre><code class="language-console">$ cargo run --example binds
bar(0x2000008c)
foo(0x20000110)
</code></pre>
<a class="header" href="#inspecting-the-expanded-code" id="inspecting-the-expanded-code"><h2>Inspecting the expanded code</h2></a>
<p><code>#[rtfm::app]</code> is a procedural macro that produces support code. If for some
reason you need to inspect the code generated by this macro you have two
options:</p>
<p>You can inspect the file <code>rtfm-expansion.rs</code> inside the <code>target</code> directory. This
file contains the expansion of the <code>#[rtfm::app]</code> item (not your whole program!)
of the <em>last built</em> (via <code>cargo build</code> or <code>cargo check</code>) RTFM application. The
expanded code is not pretty printed by default so you'll want to run <code>rustfmt</code>
over it before you read it.</p>
<pre><code class="language-console">$ cargo build --example foo

$ rustfmt target/rtfm-expansion.rs

$ tail -n30 target/rtfm-expansion.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#[doc = r&quot; Implementation details&quot;]
const APP: () = {
    use lm3s6965 as _;
    #[no_mangle]
    unsafe fn main() -&gt; ! {
        rtfm::export::interrupt::disable();
        let mut core = rtfm::export::Peripherals::steal();
        let late = init(
            init::Locals::new(),
            init::Context::new(rtfm::Peripherals {
                CBP: core.CBP,
                CPUID: core.CPUID,
                DCB: core.DCB,
                DWT: core.DWT,
                FPB: core.FPB,
                FPU: core.FPU,
                ITM: core.ITM,
                MPU: core.MPU,
                SCB: &amp;mut core.SCB,
                SYST: core.SYST,
                TPIU: core.TPIU,
            }),
        );
        core.SCB.scr.modify(|r| r | 1 &lt;&lt; 1);
        rtfm::export::interrupt::enable();
        loop {
            rtfm::export::wfi()
        }
    }
};
</code></pre></pre>
<p>Or, you can use the <a href="https://crates.io/crates/cargo-expand"><code>cargo-expand</code></a> subcommand. This subcommand will expand
<em>all</em> the macros, including the <code>#[rtfm::app]</code> attribute, and modules in your
crate and print the output to the console.</p>
<pre><code class="language-console">$ # produces the same output as before
$ cargo expand --example smallest | tail -n30
</code></pre>
<a class="header" href="#under-the-hood" id="under-the-hood"><h1>Under the hood</h1></a>
<p>This section describes the internals of the RTFM framework at a <em>high level</em>.
Low level details like the parsing and code generation done by the procedural
macro (<code>#[app]</code>) will not be explained here. The focus will be the analysis of
the user specification and the data structures used by the runtime.</p>
<p>We highly suggest that you read the embedonomicon section on <a href="https://github.com/rust-embedded/embedonomicon/pull/48">concurrency</a>
before you dive into this material.</p>
<a class="header" href="#interrupt-configuration" id="interrupt-configuration"><h1>Interrupt configuration</h1></a>
<p>Interrupts are core to the operation of RTFM applications. Correctly setting
interrupt priorities and ensuring they remain fixed at runtime is a requisite
for the memory safety of the application.</p>
<p>The RTFM framework exposes interrupt priorities as something that is declared at
compile time. However, this static configuration must be programmed into the
relevant registers during the initialization of the application. The interrupt
configuration is done before the <code>init</code> function runs.</p>
<p>This example gives you an idea of the code that the RTFM framework runs:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    #[init]
    fn init(c: init::Context) {
        // .. user code ..
    }

    #[idle]
    fn idle(c: idle::Context) -&gt; ! {
        // .. user code ..
    }

    #[interrupt(binds = UART0, priority = 2)]
    fn foo(c: foo::Context) {
        // .. user code ..
    }
};
#}</code></pre></pre>
<p>The framework generates an entry point that looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">// the real entry point of the program
#[no_mangle]
unsafe fn main() -&gt; ! {
    // transforms a logical priority into a hardware / NVIC priority
    fn logical2hw(priority: u8) -&gt; u8 {
        // this value comes from the device crate
        const NVIC_PRIO_BITS: u8 = ..;

        // the NVIC encodes priority in the higher bits of a bit
        // also a bigger numbers means lower priority
        ((1 &lt;&lt; NVIC_PRIORITY_BITS) - priority) &lt;&lt; (8 - NVIC_PRIO_BITS)
    }

    cortex_m::interrupt::disable();

    let mut core = cortex_m::Peripheral::steal();

    core.NVIC.enable(Interrupt::UART0);

    // value specified by the user
    let uart0_prio = 2;

    // check at compile time that the specified priority is within the supported range
    let _ = [(); (1 &lt;&lt; NVIC_PRIORITY_BITS) - (uart0_prio as usize)];

    core.NVIC.set_priority(Interrupt::UART0, logical2hw(uart0_prio));

    // call into user code
    init(/* .. */);

    // ..

    cortex_m::interrupt::enable();

    // call into user code
    idle(/* .. */)
}
</code></pre></pre>
<a class="header" href="#non-reentrancy" id="non-reentrancy"><h1>Non-reentrancy</h1></a>
<p>In RTFM, tasks handlers are <em>not</em> reentrant. Reentering a task handler can break
Rust aliasing rules and lead to <em>undefined behavior</em>. A task handler can be
reentered in one of two ways: in software or by hardware.</p>
<a class="header" href="#in-software" id="in-software"><h2>In software</h2></a>
<p>To reenter a task handler in software its underlying interrupt handler must be
invoked using FFI (see example below). FFI requires <code>unsafe</code> code so end users
are discouraged from directly invoking an interrupt handler.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    static mut X: u64 = 0;

    #[init]
    fn init(c: init::Context) { .. }

    #[interrupt(binds = UART0, resources = [X])]
    fn foo(c: foo::Context) {
        let x: &amp;mut u64 = c.resources.X;

        *x = 1;

        //~ `bar` can preempt `foo` at this point

        *x = 2;

        if *x == 2 {
            // something
        }
    }

    #[interrupt(binds = UART1, priority = 2)]
    fn bar(c: foo::Context) {
        extern &quot;C&quot; {
            fn UART0();
        }

        // this interrupt handler will invoke task handler `foo` resulting
        // in mutable aliasing of the static variable `X`
        unsafe { UART0() }
    }
};
#}</code></pre></pre>
<p>The RTFM framework must generate the interrupt handler code that calls the user
defined task handlers. We are careful in making these handlers <code>unsafe</code> and / or
impossible to call from user code.</p>
<p>The above example expands into:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(c: foo::Context) {
    // .. user code ..
}

fn bar(c: bar::Context) {
    // .. user code ..
}

const APP: () = {
    // everything in this block is not visible to user code

    #[no_mangle]
    unsafe fn USART0() {
        foo(..);
    }

    #[no_mangle]
    unsafe fn USART1() {
        bar(..);
    }
};
#}</code></pre></pre>
<a class="header" href="#by-hardware" id="by-hardware"><h2>By hardware</h2></a>
<p>A task handler can also be reentered without software intervention. This can
occur if the same handler is assigned to two or more interrupts in the vector
table but there's no syntax for this kind of configuration in the RTFM
framework.</p>
<a class="header" href="#access-control" id="access-control"><h1>Access control</h1></a>
<p>One of the core foundations of RTFM is access control. Controlling which parts
of the program can access which static variables is instrumental to enforcing
memory safety.</p>
<p>Static variables are used to share state between interrupt handlers, or between
interrupts handlers and the bottom execution context, <code>main</code>. In normal Rust
code it's hard to have fine grained control over which functions can access a
static variable because static variables can be accessed from any function that
resides in the same scope in which they are declared. Modules give some control
over how a static variable can be accessed by they are not flexible enough.</p>
<p>To achieve the fine-grained access control where tasks can only access the
static variables (resources) that they have specified in their RTFM attribute
the RTFM framework performs a source code level transformation. This
transformation consists of placing the resources (static variables) specified by
the user <em>inside</em> a <code>const</code> item and the user code <em>outside</em> the <code>const</code> item.
This makes it impossible for the user code to refer to these static variables.</p>
<p>Access to the resources is then given to each task using a <code>Resources</code> struct
whose fields correspond to the resources the task has access to. There's one
such struct per task and the <code>Resources</code> struct is initialized with either a
mutable reference (<code>&amp;mut</code>) to the static variables or with a resource proxy (see
section on <a href="critical-sections.html">critical sections</a>).</p>
<p>The code below is an example of the kind of source level transformation that
happens behind the scenes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    static mut X: u64: 0;
    static mut Y: bool: 0;

    #[init(resources = [Y])]
    fn init(c: init::Context) {
        // .. user code ..
    }

    #[interrupt(binds = UART0, resources = [X])]
    fn foo(c: foo::Context) {
        // .. user code ..
    }

    #[interrupt(binds = UART1, resources = [X, Y])]
    fn bar(c: bar::Context) {
        // .. user code ..
    }

    // ..
};
#}</code></pre></pre>
<p>The framework produces codes like this:</p>
<pre><pre class="playpen"><code class="language-rust">fn init(c: init::Context) {
    // .. user code ..
}

fn foo(c: foo::Context) {
    // .. user code ..
}

fn bar(c: bar::Context) {
    // .. user code ..
}

// Public API
pub mod init {
    pub struct Context&lt;'a&gt; {
        pub resources: Resources&lt;'a&gt;,
        // ..
    }

    pub struct Resources&lt;'a&gt; {
        pub Y: &amp;'a mut bool,
    }
}

pub mod foo {
    pub struct Context&lt;'a&gt; {
        pub resources: Resources&lt;'a&gt;,
        // ..
    }

    pub struct Resources&lt;'a&gt; {
        pub X: &amp;'a mut u64,
    }
}

pub mod bar {
    pub struct Context&lt;'a&gt; {
        pub resources: Resources&lt;'a&gt;,
        // ..
    }

    pub struct Resources&lt;'a&gt; {
        pub X: &amp;'a mut u64,
        pub Y: &amp;'a mut bool,
    }
}

/// Implementation details
const APP: () = {
    // everything inside this `const` item is hidden from user code

    static mut X: u64 = 0;
    static mut Y: bool = 0;

    // the real entry point of the program
    unsafe fn main() -&gt; ! {
        interrupt::disable();

        // ..

        // call into user code; pass references to the static variables
        init(init::Context {
            resources: init::Resources {
                X: &amp;mut X,
            },
            // ..
        });

        // ..

        interrupt::enable();

        // ..
    }

    // interrupt handler that `foo` binds to
    #[no_mangle]
    unsafe fn UART0() {
        // call into user code; pass references to the static variables
        foo(foo::Context {
            resources: foo::Resources {
                X: &amp;mut X,
            },
            // ..
        });
    }

    // interrupt handler that `bar` binds to
    #[no_mangle]
    unsafe fn UART1() {
        // call into user code; pass references to the static variables
        bar(bar::Context {
            resources: bar::Resources {
                X: &amp;mut X,
                Y: &amp;mut Y,
            },
            // ..
        });
    }
};
</code></pre></pre>
<a class="header" href="#late-resources-1" id="late-resources-1"><h1>Late resources</h1></a>
<p>Some resources are initialized at runtime after the <code>init</code> function returns.
It's important that these resources (static variables) are fully initialized
before tasks are allowed to run, that is they must be initialized while
interrupts are disabled.</p>
<p>The example below shows the kind of code that the framework generates to
initialize late resources.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    // late resource
    static mut X: Thing = {};

    #[init]
    fn init() -&gt; init::LateResources {
        // ..

        init::LateResources {
            X: Thing::new(..),
        }
    }

    #[task(binds = UART0, resources = [X])]
    fn foo(c: foo::Context) {
        let x: &amp;mut Thing = c.resources.X;

        x.frob();

        // ..
    }

    // ..
};
#}</code></pre></pre>
<p>The code generated by the framework looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">fn init(c: init::Context) -&gt; init::LateResources {
    // .. user code ..
}

fn foo(c: foo::Context) {
    // .. user code ..
}

// Public API
pub mod init {
    pub struct LateResources {
        pub X: Thing,
    }

    // ..
}

pub mod foo {
    pub struct Resources&lt;'a&gt; {
        pub X: &amp;'a mut Thing,
    }

    pub struct Context&lt;'a&gt; {
        pub resources: Resources&lt;'a&gt;,
        // ..
    }
}

/// Implementation details
const APP: () = {
    // uninitialized static
    static mut X: MaybeUninit&lt;Thing&gt; = MaybeUninit::uninit();

    #[no_mangle]
    unsafe fn main() -&gt; ! {
        cortex_m::interrupt::disable();

        // ..

        let late = init(..);

        // initialization of late resources
        X.write(late.X);

        cortex_m::interrupt::enable(); //~ compiler fence

        // exceptions, interrupts and tasks can preempt `main` at this point

        idle(..)
    }

    #[no_mangle]
    unsafe fn UART0() {
        foo(foo::Context {
            resources: foo::Resources {
                // `X` has been initialized at this point
                X: &amp;mut *X.as_mut_ptr(),
            },
            // ..
        })
    }
};
</code></pre></pre>
<p>An important detail here is that <code>interrupt::enable</code> behaves like a <em>compiler
fence</em>, which prevents the compiler from reordering the write to <code>X</code> to <em>after</em>
<code>interrupt::enable</code>. If the compiler were to do that kind of reordering there
would be a data race between that write and whatever operation <code>foo</code> performs on
<code>X</code>.</p>
<p>Architectures with more complex instruction pipelines may need a memory barrier
(<code>atomic::fence</code>) instead of a compiler fence to fully flush the write operation
before interrupts are re-enabled. The ARM Cortex-M architecture doesn't need a
memory barrier in single-core context.</p>
<a class="header" href="#critical-sections" id="critical-sections"><h1>Critical sections</h1></a>
<p>When a resource (static variable) is shared between two, or more, tasks that run
at different priorities some form of mutual exclusion is required to access the
memory in a data race free manner. In RTFM we use priority-based critical
sections to guarantee mutual exclusion (see the <a href="https://en.wikipedia.org/wiki/Priority_ceiling_protocol">Immediate Priority Ceiling
Protocol</a>).</p>
<p>The critical section consists of temporarily raising the <em>dynamic</em> priority of
the task. While a task is within this critical section all the other tasks that
may request the resource are <em>not allowed to start</em>.</p>
<p>How high must the dynamic priority be to ensure mutual exclusion on a particular
resource? The <a href="ceiling-analysis.html">ceiling analysis</a> is in charge of
answering that question and will be discussed in the next section. This section
will focus on the implementation of the critical section.</p>
<a class="header" href="#resource-proxy" id="resource-proxy"><h2>Resource proxy</h2></a>
<p>For simplicity, let's look at a resource shared by two tasks that run at
different priorities. Clearly one of the task can preempt the other; to prevent
a data race the <em>lower priority</em> task must use a critical section when it needs
to modify the shared memory. On the other hand, the higher priority task can
directly modify the shared memory because it can't be preempted by the lower
priority task. To enforce the use of a critical section on the lower priority
task we give it a <em>resource proxy</em>, whereas we give a mutable reference
(<code>&amp;mut-</code>) to the higher priority task.</p>
<p>The example below shows the different types handed out to each task:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    static mut X: u64 = 0;

    #[interrupt(binds = UART0, priority = 1, resources = [X])]
    fn foo(c: foo::Context) {
        // resource proxy
        let mut x: resources::X = c.resources.X;

        x.lock(|x: &amp;mut u64| {
            // critical section
            *x += 1
        });
    }

    #[interrupt(binds = UART1, priority = 2, resources = [X])]
    fn bar(c: foo::Context) {
        let mut x: &amp;mut u64 = c.resources.X;

        *x += 1;
    }

    // ..
};
#}</code></pre></pre>
<p>Now let's see how these types are created by the framework.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(c: foo::Context) {
    // .. user code ..
}

fn bar(c: bar::Context) {
    // .. user code ..
}

pub mod resources {
    pub struct X {
        // ..
    }
}

pub mod foo {
    pub struct Resources {
        pub X: resources::X,
    }

    pub struct Context {
        pub resources: Resources,
        // ..
    }
}

pub mod bar {
    pub struct Resources&lt;'a&gt; {
        pub X: rtfm::Exclusive&lt;'a, u64&gt;, // newtype over `&amp;'a mut u64`
    }

    pub struct Context {
        pub resources: Resources,
        // ..
    }
}

const APP: () = {
    static mut X: u64 = 0;

    impl rtfm::Mutex for resources::X {
        type T = u64;

        fn lock&lt;R&gt;(&amp;mut self, f: impl FnOnce(&amp;mut u64) -&gt; R) -&gt; R {
            // we'll check this in detail later
        }
    }

    #[no_mangle]
    unsafe fn UART0() {
        foo(foo::Context {
            resources: foo::Resources {
                X: resources::X::new(/* .. */),
            },
            // ..
        })
    }

    #[no_mangle]
    unsafe fn UART1() {
        bar(bar::Context {
            resources: bar::Resources {
                X: rtfm::Exclusive(&amp;mut X),
            },
            // ..
        })
    }
};
#}</code></pre></pre>
<a class="header" href="#lock" id="lock"><h2><code>lock</code></h2></a>
<p>Let's now zoom into the critical section itself. In this example, we have to
raise the dynamic priority to at least <code>2</code> to prevent a data race. On the
Cortex-M architecture the dynamic priority can be changed by writing to the
<code>BASEPRI</code> register.</p>
<p>The semantics of the <code>BASEPRI</code> register are as follows:</p>
<ul>
<li>Writing a value of <code>0</code> to <code>BASEPRI</code> disables its functionality.</li>
<li>Writing a non-zero value to <code>BASEPRI</code> changes the priority level required for
interrupt preemption. However, this only has an effect when the written value
is <em>lower</em> than the priority level of current execution context, but note that
a lower hardware priority level means higher logical priority</li>
</ul>
<p>Thus the dynamic priority at any point in time can be computed as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
dynamic_priority = max(hw2logical(BASEPRI), hw2logical(static_priority))
#}</code></pre></pre>
<p>Where <code>static_priority</code> is the priority programmed in the NVIC for the current
interrupt, or a logical <code>0</code> when the current context is <code>idle</code>.</p>
<p>In this particular example we could implement the critical section as follows:</p>
<blockquote>
<p><strong>NOTE:</strong> this is a simplified implementation</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl rtfm::Mutex for resources::X {
    type T = u64;

    fn lock&lt;R, F&gt;(&amp;mut self, f: F) -&gt; R
    where
        F: FnOnce(&amp;mut u64) -&gt; R,
    {
        unsafe {
            // start of critical section: raise dynamic priority to `2`
            asm!(&quot;msr BASEPRI, 192&quot; : : : &quot;memory&quot; : &quot;volatile&quot;);

            // run user code within the critical section
            let r = f(&amp;mut implementation_defined_name_for_X);

            // end of critical section: restore dynamic priority to its static value (`1`)
            asm!(&quot;msr BASEPRI, 0&quot; : : : &quot;memory&quot; : &quot;volatile&quot;);

            r
        }
    }
}
#}</code></pre></pre>
<p>Here it's important to use the <code>&quot;memory&quot;</code> clobber in the <code>asm!</code> block. It
prevents the compiler from reordering memory operations across it. This is
important because accessing the variable <code>X</code> outside the critical section would
result in a data race.</p>
<p>It's important to note that the signature of the <code>lock</code> method prevents nesting
calls to it. This is required for memory safety, as nested calls would produce
multiple mutable references (<code>&amp;mut-</code>) to <code>X</code> breaking Rust aliasing rules. See
below:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[interrupt(binds = UART0, priority = 1, resources = [X])]
fn foo(c: foo::Context) {
    // resource proxy
    let mut res: resources::X = c.resources.X;

    res.lock(|x: &amp;mut u64| {
        res.lock(|alias: &amp;mut u64| {
            //~^ error: `res` has already been mutably borrowed
            // ..
        });
    });
}
#}</code></pre></pre>
<a class="header" href="#nesting" id="nesting"><h2>Nesting</h2></a>
<p>Nesting calls to <code>lock</code> on the <em>same</em> resource must be rejected by the compiler
for memory safety but nesting <code>lock</code> calls on <em>different</em> resources is a valid
operation. In that case we want to make sure that nesting critical sections
never results in lowering the dynamic priority, as that would be unsound, and we
also want to optimize the number of writes to the <code>BASEPRI</code> register and
compiler fences. To that end we'll track the dynamic priority of the task using
a stack variable and use that to decide whether to write to <code>BASEPRI</code> or not. In
practice, the stack variable will be optimized away by the compiler but it still
provides extra information to the compiler.</p>
<p>Consider this program:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    static mut X: u64 = 0;
    static mut Y: u64 = 0;

    #[init]
    fn init() {
        rtfm::pend(Interrupt::UART0);
    }

    #[interrupt(binds = UART0, priority = 1, resources = [X, Y])]
    fn foo(c: foo::Context) {
        let mut x = c.resources.X;
        let mut y = c.resources.Y;

        y.lock(|y| {
            *y += 1;

            *x.lock(|x| {
                x += 1;
            });

            *y += 1;
        });

        // mid-point

        x.lock(|x| {
            *x += 1;

            y.lock(|y| {
                *y += 1;
            });

            *x += 1;
        })
    }

    #[interrupt(binds = UART1, priority = 2, resources = [X])]
    fn bar(c: foo::Context) {
        // ..
    }

    #[interrupt(binds = UART2, priority = 3, resources = [Y])]
    fn baz(c: foo::Context) {
        // ..
    }

    // ..
};
#}</code></pre></pre>
<p>The code generated by the framework looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// omitted: user code

pub mod resources {
    pub struct X&lt;'a&gt; {
        priority: &amp;'a Cell&lt;u8&gt;,
    }

    impl&lt;'a&gt; X&lt;'a&gt; {
        pub unsafe fn new(priority: &amp;'a Cell&lt;u8&gt;) -&gt; Self {
            X { priority }
        }

        pub unsafe fn priority(&amp;self) -&gt; &amp;Cell&lt;u8&gt; {
            self.priority
        }
    }

    // repeat for `Y`
}

pub mod foo {
    pub struct Context {
        pub resources: Resources,
        // ..
    }

    pub struct Resources&lt;'a&gt; {
        pub X: resources::X&lt;'a&gt;,
        pub Y: resources::Y&lt;'a&gt;,
    }
}

const APP: () = {
    #[no_mangle]
    unsafe fn UART0() {
        // the static priority of this interrupt (as specified by the user)
        const PRIORITY: u8 = 1;

        // take a snashot of the BASEPRI
        let initial: u8;
        asm!(&quot;mrs $0, BASEPRI&quot; : &quot;=r&quot;(initial) : : : &quot;volatile&quot;);

        let priority = Cell::new(PRIORITY);
        foo(foo::Context {
            resources: foo::Resources::new(&amp;priority),
            // ..
        });

        // roll back the BASEPRI to the snapshot value we took before
        asm!(&quot;msr BASEPRI, $0&quot; : : &quot;r&quot;(initial) : : &quot;volatile&quot;);
    }

    // similarly for `UART1`

    impl&lt;'a&gt; rtfm::Mutex for resources::X&lt;'a&gt; {
        type T = u64;

        fn lock&lt;R&gt;(&amp;mut self, f: impl FnOnce(&amp;mut u64) -&gt; R) -&gt; R {
            unsafe {
                // the priority ceiling of this resource
                const CEILING: u8 = 2;

                let current = self.priority().get();
                if current &lt; CEILING {
                    // raise dynamic priority
                    self.priority().set(CEILING);
                    let hw = logical2hw(CEILING);
                    asm!(&quot;msr BASEPRI, $0&quot; : : &quot;r&quot;(hw) : &quot;memory&quot; : &quot;volatile&quot;);

                    let r = f(&amp;mut X);

                    // restore dynamic priority
                    let hw = logical2hw(current);
                    asm!(&quot;msr BASEPRI, $0&quot; : : &quot;r&quot;(hw) : &quot;memory&quot; : &quot;volatile&quot;);
                    self.priority().set(current);

                    r
                } else {
                    // dynamic priority is high enough
                    f(&amp;mut X)
                }
            }
        }
    }

    // repeat for `Y`
};
#}</code></pre></pre>
<p>At the end the compiler will optimize the function <code>foo</code> into something like
this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(c: foo::Context) {
    // NOTE: BASEPRI contains the value `0` (its reset value) at this point

    // raise dynamic priority to `3`
    unsafe { asm!(&quot;msr BASEPRI, 160&quot; : : : &quot;memory&quot; : &quot;volatile&quot;) }

    // the two operations on `Y` are merged into one
    Y += 2;

    // BASEPRI is not modified to access `X` because the dynamic priority is high enough
    X += 1;

    // lower (restore) the dynamic priority to `1`
    unsafe { asm!(&quot;msr BASEPRI, 224&quot; : : : &quot;memory&quot; : &quot;volatile&quot;) }

    // mid-point

    // raise dynamic priority to `2`
    unsafe { asm!(&quot;msr BASEPRI, 192&quot; : : : &quot;memory&quot; : &quot;volatile&quot;) }

    X += 1;

    // raise dynamic priority to `3`
    unsafe { asm!(&quot;msr BASEPRI, 160&quot; : : : &quot;memory&quot; : &quot;volatile&quot;) }

    Y += 1;

    // lower (restore) the dynamic priority to `2`
    unsafe { asm!(&quot;msr BASEPRI, 192&quot; : : : &quot;memory&quot; : &quot;volatile&quot;) }

    // NOTE: it would be sound to merge this operation on X with the previous one but
    // compiler fences are coarse grained and prevent such optimization
    X += 1;

    // lower (restore) the dynamic priority to `1`
    unsafe { asm!(&quot;msr BASEPRI, 224&quot; : : : &quot;memory&quot; : &quot;volatile&quot;) }

    // NOTE: BASEPRI contains the value `224` at this point
    // the UART0 handler will restore the value to `0` before returning
}
#}</code></pre></pre>
<a class="header" href="#the-basepri-invariant" id="the-basepri-invariant"><h2>The BASEPRI invariant</h2></a>
<p>An invariant that the RTFM framework has to preserve is that the value of the
BASEPRI at the start of an <em>interrupt</em> handler must be the same value it has
when the interrupt handler returns. BASEPRI may change during the execution of
the interrupt handler but running an interrupt handler from start to finish
should not result in an observable change of BASEPRI.</p>
<p>This invariant needs to be preserved to avoid raising the dynamic priority of a
handler through preemption. This is best observed in the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    static mut X: u64 = 0;

    #[init]
    fn init() {
        // `foo` will run right after `init` returns
        rtfm::pend(Interrupt::UART0);
    }

    #[task(binds = UART0, priority = 1)]
    fn foo() {
        // BASEPRI is `0` at this point; the dynamic priority is currently `1`

        // `bar` will preempt `foo` at this point
        rtfm::pend(Interrupt::UART1);

        // BASEPRI is `192` at this point (due to a bug); the dynamic priority is now `2`
        // this function returns to `idle`
    }

    #[task(binds = UART1, priority = 2, resources = [X])]
    fn bar() {
        // BASEPRI is `0` (dynamic priority = 2)

        X.lock(|x| {
            // BASEPRI is raised to `160` (dynamic priority = 3)

            // ..
        });

        // BASEPRI is restored to `192` (dynamic priority = 2)
    }

    #[idle]
    fn idle() -&gt; ! {
        // BASEPRI is `192` (due to a bug); dynamic priority = 2

        // this has no effect due to the BASEPRI value
        // the task `foo` will never be executed again
        rtfm::pend(Interrupt::UART0);

        loop {
            // ..
        }
    }

    #[task(binds = UART2, priority = 3, resources = [X])]
    fn baz() {
        // ..
    }

};
#}</code></pre></pre>
<p>IMPORTANT: let's say we <em>forget</em> to roll back <code>BASEPRI</code> in <code>UART1</code> -- this would
be a bug in the RTFM code generator.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// code generated by RTFM

const APP: () = {
    // ..

    #[no_mangle]
    unsafe fn UART1() {
        // the static priority of this interrupt (as specified by the user)
        const PRIORITY: u8 = 2;

        // take a snashot of the BASEPRI
        let initial: u8;
        asm!(&quot;mrs $0, BASEPRI&quot; : &quot;=r&quot;(initial) : : : &quot;volatile&quot;);

        let priority = Cell::new(PRIORITY);
        bar(bar::Context {
            resources: bar::Resources::new(&amp;priority),
            // ..
        });

        // BUG: FORGOT to roll back the BASEPRI to the snapshot value we took before
        // asm!(&quot;msr BASEPRI, $0&quot; : : &quot;r&quot;(initial) : : &quot;volatile&quot;);
    }
};
#}</code></pre></pre>
<p>The consequence is that <code>idle</code> will run at a dynamic priority of <code>2</code> and in fact
the system will never again run at a dynamic priority lower than <code>2</code>. This
doesn't compromise the memory safety of the program but affects task scheduling:
in this particular case tasks with a priority of <code>1</code> will never get a chance to
run.</p>
<a class="header" href="#ceiling-analysis" id="ceiling-analysis"><h1>Ceiling analysis</h1></a>
<p>A resource <em>priority ceiling</em>, or just <em>ceiling</em>, is the dynamic priority that
any task must have to safely access the resource memory. Ceiling analysis is
relatively simple but critical to the memory safety of RTFM applications.</p>
<p>To compute the ceiling of a resource we must first collect a list of tasks that
have access to the resource -- as the RTFM framework enforces access control to
resources at compile time it also has access to this information at compile
time. The ceiling of the resource is simply the highest logical priority among
those tasks.</p>
<p><code>init</code> and <code>idle</code> are not proper tasks but they can access resources so they
need to be considered in the ceiling analysis. <code>idle</code> is considered as a task
that has a logical priority of <code>0</code> whereas <code>init</code> is completely omitted from the
analysis -- the reason for that is that <code>init</code> never uses (or needs) critical
sections to access static variables.</p>
<p>In the previous section we showed that a shared resource may appear as a mutable
reference or behind a proxy depending on the task that has access to it. Which
version is presented to the task depends on the task priority and the resource
ceiling. If the task priority is the same as the resource ceiling then the task
gets a mutable reference to the resource memory, otherwise the task gets a
proxy -- this also applies to <code>idle</code>. <code>init</code> is special: it always gets a
mutable reference to resources.</p>
<p>An example to illustrate the ceiling analysis:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    // accessed by `foo` (prio = 1) and `bar` (prio = 2)
    // CEILING = 2
    static mut X: u64 = 0;

    // accessed by `idle` (prio = 0)
    // CEILING = 0
    static mut Y: u64 = 0;

    #[init(resources = [X])]
    fn init(c: init::Context) {
        // mutable reference because this is `init`
        let x: &amp;mut u64 = c.resources.X;

        // mutable reference because this is `init`
        let y: &amp;mut u64 = c.resources.Y;

        // ..
    }

    // PRIORITY = 0
    #[idle(resources = [Y])]
    fn idle(c: idle::Context) -&gt; ! {
        // mutable reference because priority (0) == resource ceiling (0)
        let y: &amp;'static mut u64 = c.resources.Y;

        loop {
            // ..
        }
    }

    #[interrupt(binds = UART0, priority = 1, resources = [X])]
    fn foo(c: foo::Context) {
        // resource proxy because task priority (1) &lt; resource ceiling (2)
        let x: resources::X = c.resources.X;

        // ..
    }

    #[interrupt(binds = UART1, priority = 2, resources = [X])]
    fn bar(c: foo::Context) {
        // mutable reference because task priority (2) == resource ceiling (2)
        let x: &amp;mut u64 = c.resources.X;

        // ..
    }

    // ..
};
#}</code></pre></pre>
<a class="header" href="#software-tasks-1" id="software-tasks-1"><h1>Software tasks</h1></a>
<p>RTFM supports software tasks and hardware tasks. Each hardware task is bound to
a different interrupt handler. On the other hand, several software tasks may be
dispatched by the same interrupt handler -- this is done to minimize the number
of interrupts handlers used by the framework.</p>
<p>The framework groups <code>spawn</code>-able tasks by priority level and generates one
<em>task dispatcher</em> per priority level. Each task dispatcher runs on a different
interrupt handler and the priority of said interrupt handler is set to match the
priority level of the tasks managed by the dispatcher.</p>
<p>Each task dispatcher keeps a <em>queue</em> of tasks which are <em>ready</em> to execute; this
queue is referred to as the <em>ready queue</em>. Spawning a software task consists of
adding an entry to this queue and pending the interrupt that runs the
corresponding task dispatcher. Each entry in this queue contains a tag (<code>enum</code>)
that identifies the task to execute and a <em>pointer</em> to the message passed to the
task.</p>
<p>The ready queue is a SPSC (Single Producer Single Consumer) lock-free queue. The
task dispatcher owns the consumer endpoint of the queue; the producer endpoint
is treated as a resource shared by the tasks that can <code>spawn</code> other tasks.</p>
<a class="header" href="#the-task-dispatcher" id="the-task-dispatcher"><h2>The task dispatcher</h2></a>
<p>Let's first take a look the code generated by the framework to dispatch tasks.
Consider this example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    // ..

    #[interrupt(binds = UART0, priority = 2, spawn = [bar, baz])]
    fn foo(c: foo::Context) {
        foo.spawn.bar().ok();

        foo.spawn.baz(42).ok();
    }

    #[task(capacity = 2, priority = 1)]
    fn bar(c: bar::Context) {
        // ..
    }

    #[task(capacity = 2, priority = 1, resources = [X])]
    fn baz(c: baz::Context, input: i32) {
        // ..
    }

    extern &quot;C&quot; {
        fn UART1();
    }
};
#}</code></pre></pre>
<p>The framework produces the following task dispatcher which consists of an
interrupt handler and a ready queue:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn bar(c: bar::Context) {
    // .. user code ..
}

const APP: () = {
    use heapless::spsc::Queue;
    use cortex_m::register::basepri;

    struct Ready&lt;T&gt; {
        task: T,
        // ..
    }

    /// `spawn`-able tasks that run at priority level `1`
    enum T1 {
        bar,
        baz,
    }

    // ready queue of the task dispatcher
    // `U4` is a type-level integer that represents the capacity of this queue
    static mut RQ1: Queue&lt;Ready&lt;T1&gt;, U4&gt; = Queue::new();

    // interrupt handler chosen to dispatch tasks at priority `1`
    #[no_mangle]
    unsafe UART1() {
        // the priority of this interrupt handler
        const PRIORITY: u8 = 1;

        let snapshot = basepri::read();

        while let Some(ready) = RQ1.split().1.dequeue() {
            match ready.task {
                T1::bar =&gt; {
                    // **NOTE** simplified implementation

                    // used to track the dynamic priority
                    let priority = Cell::new(PRIORITY);

                    // call into user code
                    bar(bar::Context::new(&amp;priority));
                }

                T1::baz =&gt; {
                    // we'll look at `baz` later
                }
            }
        }

        // BASEPRI invariant
        basepri::write(snapshot);
    }
};
#}</code></pre></pre>
<a class="header" href="#spawning-a-task" id="spawning-a-task"><h2>Spawning a task</h2></a>
<p>The <code>spawn</code> API is exposed to the user as the methods of a <code>Spawn</code> struct.
There's one <code>Spawn</code> struct per task.</p>
<p>The <code>Spawn</code> code generated by the framework for the previous example looks like
this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    // ..

    pub struct Context&lt;'a&gt; {
        pub spawn: Spawn&lt;'a&gt;,
        // ..
    }

    pub struct Spawn&lt;'a&gt; {
        // tracks the dynamic priority of the task
        priority: &amp;'a Cell&lt;u8&gt;,
    }

    impl&lt;'a&gt; Spawn&lt;'a&gt; {
        // `unsafe` and hidden because we don't want the user to tamper with it
        #[doc(hidden)]
        pub unsafe fn priority(&amp;self) -&gt; &amp;Cell&lt;u8&gt; {
            self.priority
        }
    }
}

const APP: () = {
    // ..

    // Priority ceiling for the producer endpoint of the `RQ1`
    const RQ1_CEILING: u8 = 2;

    // used to track how many more `bar` messages can be enqueued
    // `U2` is the capacity of the `bar` task; a max of two instances can be queued
    // this queue is filled by the framework before `init` runs
    static mut bar_FQ: Queue&lt;(), U2&gt; = Queue::new();

    // Priority ceiling for the consumer endpoint of `bar_FQ`
    const bar_FQ_CEILING: u8 = 2;

    // a priority-based critical section
    //
    // this run the given closure `f` at a dynamic priority of at least
    // `ceiling`
    fn lock(priority: &amp;Cell&lt;u8&gt;, ceiling: u8, f: impl FnOnce()) {
        // ..
    }

    impl&lt;'a&gt; foo::Spawn&lt;'a&gt; {
        /// Spawns the `bar` task
        pub fn bar(&amp;self) -&gt; Result&lt;(), ()&gt; {
            unsafe {
                match lock(self.priority(), bar_FQ_CEILING, || {
                    bar_FQ.split().1.dequeue()
                }) {
                    Some(()) =&gt; {
                        lock(self.priority(), RQ1_CEILING, || {
                            // put the taks in the ready queue
                            RQ1.split().1.enqueue_unchecked(Ready {
                                task: T1::bar,
                                // ..
                            })
                        });

                        // pend the interrupt that runs the task dispatcher
                        rtfm::pend(Interrupt::UART0);
                    }

                    None =&gt; {
                        // maximum capacity reached; spawn failed
                        Err(())
                    }
                }
            }
        }
    }
};
#}</code></pre></pre>
<p>Using <code>bar_FQ</code> to limit the number of <code>bar</code> tasks that can be spawned may seem
like an artificial limitation but it will make more sense when we talk about
task capacities.</p>
<a class="header" href="#messages" id="messages"><h2>Messages</h2></a>
<p>We have omitted how message passing actually works so let's revisit the <code>spawn</code>
implementation but this time for task <code>baz</code> which receives a <code>u64</code> message.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn baz(c: baz::Context, input: u64) {
    // .. user code ..
}

const APP: () = {
    // ..

    // Now we show the full contents of the `Ready` struct
    struct Ready {
        task: Task,
        // message index; used to index the `INPUTS` buffer
        index: u8,
    }

    // memory reserved to hold messages passed to `baz`
    static mut baz_INPUTS: [MaybeUninit&lt;u64&gt;; 2] =
        [MaybeUninit::uninit(), MaybeUninit::uninit()];

    // the free queue: used to track free slots in the `baz_INPUTS` array
    // this queue is initialized with values `0` and `1` before `init` is executed
    static mut baz_FQ: Queue&lt;u8, U2&gt; = Queue::new();

    // Priority ceiling for the consumer endpoint of `baz_FQ`
    const baz_FQ_CEILING: u8 = 2;

    impl&lt;'a&gt; foo::Spawn&lt;'a&gt; {
        /// Spawns the `baz` task
        pub fn baz(&amp;self, message: u64) -&gt; Result&lt;(), u64&gt; {
            unsafe {
                match lock(self.priority(), baz_FQ_CEILING, || {
                    baz_FQ.split().1.dequeue()
                }) {
                    Some(index) =&gt; {
                        // NOTE: `index` is an ownining pointer into this buffer
                        baz_INPUTS[index as usize].write(message);

                        lock(self.priority(), RQ1_CEILING, || {
                            // put the task in the ready queu
                            RQ1.split().1.enqueue_unchecked(Ready {
                                task: T1::baz,
                                index,
                            });
                        });

                        // pend the interrupt that runs the task dispatcher
                        rtfm::pend(Interrupt::UART0);
                    }

                    None =&gt; {
                        // maximum capacity reached; spawn failed
                        Err(message)
                    }
                }
            }
        }
    }
};
#}</code></pre></pre>
<p>And now let's look at the real implementation of the task dispatcher:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const APP: () = {
    // ..

    #[no_mangle]
    unsafe UART1() {
        const PRIORITY: u8 = 1;

        let snapshot = basepri::read();

        while let Some(ready) = RQ1.split().1.dequeue() {
            match ready.task {
                Task::baz =&gt; {
                    // NOTE: `index` is an ownining pointer into this buffer
                    let input = baz_INPUTS[ready.index as usize].read();

                    // the message has been read out so we can return the slot
                    // back to the free queue
                    // (the task dispatcher has exclusive access to the producer
                    // endpoint of this queue)
                    baz_FQ.split().0.enqueue_unchecked(ready.index);

                    let priority = Cell::new(PRIORITY);
                    baz(baz::Context::new(&amp;priority), input)
                }

                Task::bar =&gt; {
                    // looks just like the `baz` branch
                }

            }
        }

        // BASEPRI invariant
        basepri::write(snapshot);
    }
};
#}</code></pre></pre>
<p><code>INPUTS</code> plus <code>FQ</code>, the free queue, is effectively a memory pool. However,
instead of using the usual <em>free list</em> (linked list) to track empty slots
in the <code>INPUTS</code> buffer we use a SPSC queue; this lets us reduce the number of
critical sections. In fact, thanks to this choice the task dispatching code is
lock-free.</p>
<a class="header" href="#queue-capacity" id="queue-capacity"><h2>Queue capacity</h2></a>
<p>The RTFM framework uses several queues like ready queues and free queues. When
the free queue is empty trying to <code>spawn</code> a task results in an error; this
condition is checked at runtime. Not all the operations performed by the
framework on these queues check if the queue is empty / full. For example,
returning an slot to the free queue (see the task dispatcher) is unchecked
because there's a fixed number of such slots circulating in the system that's
equal to the capacity of the free queue. Similarly, adding an entry to the ready
queue (see <code>Spawn</code>) is unchecked because of the queue capacity chosen by the
framework.</p>
<p>Users can specify the capacity of software tasks; this capacity is the maximum
number of messages one can post to said task from a higher priority task before
<code>spawn</code> returns an error. This user-specified capacity is the capacity of the
free queue of the task (e.g. <code>foo_FQ</code>) and also the size of the array that holds
the inputs to the task (e.g. <code>foo_INPUTS</code>).</p>
<p>The capacity of the ready queue (e.g. <code>RQ1</code>) is chosen to be the <em>sum</em> of the
capacities of all the different tasks managed by the dispatcher; this sum is
also the number of messages the queue will hold in the worst case scenario of
all possible messages being posted before the task dispatcher gets a chance to
run. For this reason, getting a slot from the free queue in any <code>spawn</code>
operation implies that the ready queue is not yet full so inserting an entry
into the ready queue can omit the &quot;is it full?&quot; check.</p>
<p>In our running example the task <code>bar</code> takes no input so we could have omitted
both <code>bar_INPUTS</code> and <code>bar_FQ</code> and let the user post an unbounded number of
messages to this task, but if we did that it would have not be possible to pick
a capacity for <code>RQ1</code> that lets us omit the &quot;is it full?&quot; check when spawning a
<code>baz</code> task. In the section about the <a href="timer-queue.html">timer queue</a> we'll see
how the free queue is used by tasks that have no inputs.</p>
<a class="header" href="#ceiling-analysis-1" id="ceiling-analysis-1"><h2>Ceiling analysis</h2></a>
<p>The queues internally used by the <code>spawn</code> API are treated like normal resources
and included in the ceiling analysis. It's important to note that these are SPSC
queues and that only one of the endpoints is behind a resource; the other
endpoint is owned by a task dispatcher.</p>
<p>Consider the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    #[idle(spawn = [foo, bar])]
    fn idle(c: idle::Context) -&gt; ! {
        // ..
    }

    #[task]
    fn foo(c: foo::Context) {
        // ..
    }

    #[task]
    fn bar(c: bar::Context) {
        // ..
    }

    #[task(priority = 2, spawn = [foo])]
    fn baz(c: baz::Context) {
        // ..
    }

    #[task(priority = 3, spawn = [bar])]
    fn quux(c: quux::Context) {
        // ..
    }
};
#}</code></pre></pre>
<p>This is how the ceiling analysis would go:</p>
<ul>
<li>
<p><code>idle</code> (prio = 0) and <code>baz</code> (prio = 2) contend for the consumer endpoint of
<code>foo_FQ</code>; this leads to a priority ceiling of <code>2</code>.</p>
</li>
<li>
<p><code>idle</code> (prio = 0) and <code>quux</code> (prio = 3) contend for the consumer endpoint of
<code>bar_FQ</code>; this leads to a priority ceiling of <code>3</code>.</p>
</li>
<li>
<p><code>idle</code> (prio = 0), <code>baz</code> (prio = 2) and <code>quux</code> (prio = 3) all contend for the
producer endpoint of <code>RQ1</code>; this leads to a priority ceiling of <code>3</code></p>
</li>
</ul>
<a class="header" href="#timer-queue-1" id="timer-queue-1"><h1>Timer queue</h1></a>
<p>The timer queue functionality lets the user schedule tasks to run at some time
in the future. Unsurprisingly, this feature is also implemented using a queue:
a priority queue where the scheduled tasks are kept sorted by earliest scheduled
time. This feature requires a timer capable of setting up timeout interrupts.
The timer is used to trigger an interrupt when the scheduled time of a task is
up; at that point the task is removed from the timer queue and moved into the
appropriate ready queue.</p>
<p>Let's see how this in implemented in code. Consider the following program:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    // ..

    #[task(capacity = 2, schedule = [foo])]
    fn foo(c: foo::Context, x: u32) {
        // schedule this task to run again in 1M cycles
        c.schedule.foo(c.scheduled + Duration::cycles(1_000_000), x + 1).ok();
    }

    extern &quot;C&quot; {
        fn UART0();
    }
};
#}</code></pre></pre>
<a class="header" href="#schedule" id="schedule"><h2><code>schedule</code></h2></a>
<p>Let's first look at the <code>schedule</code> API.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    pub struct Schedule&lt;'a&gt; {
        priority: &amp;'a Cell&lt;u8&gt;,
    }

    impl&lt;'a&gt; Schedule&lt;'a&gt; {
        // unsafe and hidden because we don't want the user to tamper with this
        #[doc(hidden)]
        pub unsafe fn priority(&amp;self) -&gt; &amp;Cell&lt;u8&gt; {
            self.priority
        }
    }
}

const APP: () = {
    use rtfm::Instant;

    // all tasks that can be `schedule`-d
    enum T {
        foo,
    }

    struct NotReady {
        index: u8,
        instant: Instant,
        task: T,
    }

    // The timer queue is a binary (min) heap of `NotReady` tasks
    static mut TQ: TimerQueue&lt;U2&gt; = ..;
    const TQ_CEILING: u8 = 1;

    static mut foo_FQ: Queue&lt;u8, U2&gt; = Queue::new();
    const foo_FQ_CEILING: u8 = 1;

    static mut foo_INPUTS: [MaybeUninit&lt;u32&gt;; 2] =
        [MaybeUninit::uninit(), MaybeUninit::uninit()];

    static mut foo_INSTANTS: [MaybeUninit&lt;Instant&gt;; 2] =
        [MaybeUninit::uninit(), MaybeUninit::uninit()];

    impl&lt;'a&gt; foo::Schedule&lt;'a&gt; {
        fn foo(&amp;self, instant: Instant, input: u32) -&gt; Result&lt;(), u32&gt; {
            unsafe {
                let priority = self.priority();
                if let Some(index) = lock(priority, foo_FQ_CEILING, || {
                    foo_FQ.split().1.dequeue()
                }) {
                    // `index` is an owning pointer into these buffers
                    foo_INSTANTS[index as usize].write(instant);
                    foo_INPUTS[index as usize].write(input);

                    let nr = NotReady {
                        index,
                        instant,
                        task: T::foo,
                    };

                    lock(priority, TQ_CEILING, || {
                        TQ.enqueue_unchecked(nr);
                    });
                } else {
                    // No space left to store the input / instant
                    Err(input)
                }
            }
        }
    }
};
#}</code></pre></pre>
<p>This looks very similar to the <code>Spawn</code> implementation. In fact, the same
<code>INPUTS</code> buffer and free queue (<code>FQ</code>) are shared between the <code>spawn</code> and
<code>schedule</code> APIs. The main difference between the two is that <code>schedule</code> also
stores the <code>Instant</code> at which the task was scheduled to run in a separate buffer
(<code>foo_INSTANTS</code> in this case).</p>
<p><code>TimerQueue::enqueue_unchecked</code> does a bit more work that just adding the entry
into a min-heap: it also pends the system timer interrupt (<code>SysTick</code>) if the new
entry ended up first in the queue.</p>
<a class="header" href="#the-system-timer" id="the-system-timer"><h2>The system timer</h2></a>
<p>The system timer interrupt (<code>SysTick</code>) takes cares of two things: moving tasks
that have become ready from the timer queue into the right ready queue and
setting up a timeout interrupt to fire when the scheduled time of the next task
is up.</p>
<p>Let's see the associated code.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const APP: () = {
    #[no_mangle]
    fn SysTick() {
        const PRIORITY: u8 = 1;

        let priority = &amp;Cell::new(PRIORITY);
        while let Some(ready) = lock(priority, TQ_CEILING, || TQ.dequeue()) {
            match ready.task {
                T::foo =&gt; {
                    // move this task into the `RQ1` ready queue
                    lock(priority, RQ1_CEILING, || {
                        RQ1.split().0.enqueue_unchecked(Ready {
                           task: T1::foo,
                           index: ready.index,
                        })
                    });

                    // pend the task dispatcher
                    rtfm::pend(Interrupt::UART0);
                }
            }
        }
    }
};
#}</code></pre></pre>
<p>This looks similar to a task dispatcher except that instead of running the
ready task this only places the task in the corresponding ready queue, that
way it will run at the right priority.</p>
<p><code>TimerQueue::dequeue</code> will set up a new timeout interrupt when it returns
<code>None</code>. This ties in with <code>TimerQueue::enqueue_unchecked</code>, which pends this
handler; basically, <code>enqueue_unchecked</code> delegates the task of setting up a new
timeout interrupt to the <code>SysTick</code> handler.</p>
<a class="header" href="#resolution-and-range-of-instant-and-duration" id="resolution-and-range-of-instant-and-duration"><h2>Resolution and range of <code>Instant</code> and <code>Duration</code></h2></a>
<p>In the current implementation the <code>DWT</code>'s (Data Watchpoint and Trace) cycle
counter is used as a monotonic timer. <code>Instant::now</code> returns a snapshot of this
timer; these DWT snapshots (<code>Instant</code>s) are used to sort entries in the timer
queue. The cycle counter is a 32-bit counter clocked at the core clock
frequency. This counter wraps around every <code>(1 &lt;&lt; 32)</code> clock cycles; there's no
interrupt associated to this counter so nothing worth noting happens when it
wraps around.</p>
<p>To order <code>Instant</code>s in the queue we need to compare two 32-bit integers. To
account for the wrap-around behavior we use the difference between two
<code>Instant</code>s, <code>a - b</code>, and treat the result as a 32-bit signed integer. If the
result is less than zero then <code>b</code> is a later <code>Instant</code>; if the result is greater
than zero then <code>b</code> is an earlier <code>Instant</code>. This means that scheduling a task at
an <code>Instant</code> that's <code>(1 &lt;&lt; 31) - 1</code> cycles greater than the scheduled time
(<code>Instant</code>) of the first (earliest) entry in the queue will cause the task to be
inserted at the wrong place in the queue. There some debug assertions in place
to prevent this user error but it can't be avoided because the user can write
<code>(instant + duration_a) + duration_b</code> and overflow the <code>Instant</code>.</p>
<p>The system timer, <code>SysTick</code>, is a 24-bit counter also clocked at the core clock
frequency. When the next scheduled task is more than <code>1 &lt;&lt; 24</code> clock cycles in
the future an interrupt is set to go off in <code>1 &lt;&lt; 24</code> cycles. This process may
need to happen several times until the next scheduled task is within the range
of the <code>SysTick</code> counter.</p>
<p>In conclusion, both <code>Instant</code> and <code>Duration</code> have a resolution of 1 core clock
cycle and <code>Duration</code> effectively has a (half-open) range of <code>0..(1 &lt;&lt; 31)</code> (end
not included) core clock cycles.</p>
<a class="header" href="#queue-capacity-1" id="queue-capacity-1"><h2>Queue capacity</h2></a>
<p>The capacity of the timer queue is chosen to be the sum of the capacities of all
<code>schedule</code>-able tasks. Like in the case of the ready queues, this means that
once we have claimed a free slot in the <code>INPUTS</code> buffer we are guaranteed to be
able to insert the task in the timer queue; this lets us omit runtime checks.</p>
<a class="header" href="#system-timer-priority" id="system-timer-priority"><h2>System timer priority</h2></a>
<p>The priority of the system timer can't set by the user; it is chosen by the
framework. To ensure that lower priority tasks don't prevent higher priority
tasks from running we choose the priority of the system timer to be the maximum
of all the <code>schedule</code>-able tasks.</p>
<p>To see why this is required consider the case where two previously scheduled
tasks with priorities <code>2</code> and <code>3</code> become ready at about the same time but the
lower priority task is moved into the ready queue first. If the system timer
priority was, for example, <code>1</code> then after moving the lower priority (<code>2</code>) task
it would run to completion (due to it being higher priority than the system
timer) delaying the execution of the higher priority (<code>3</code>) task. To prevent
scenarios like these the system timer must match the highest priority of the
<code>schedule</code>-able tasks; in this example that would be <code>3</code>.</p>
<a class="header" href="#ceiling-analysis-2" id="ceiling-analysis-2"><h2>Ceiling analysis</h2></a>
<p>The timer queue is a resource shared between all the tasks that can <code>schedule</code> a
task and the <code>SysTick</code> handler. Also the <code>schedule</code> API contends with the
<code>spawn</code> API over the free queues. All this must be considered in the ceiling
analysis.</p>
<p>To illustrate, consider the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[rtfm::app(device = ..)]
const APP: () = {
    #[task(priority = 3, spawn = [baz])]
    fn foo(c: foo::Context) {
        // ..
    }

    #[task(priority = 2, schedule = [foo, baz])]
    fn bar(c: bar::Context) {
        // ..
    }

    #[task(priority = 1)]
    fn baz(c: baz::Context) {
        // ..
    }
};
#}</code></pre></pre>
<p>The ceiling analysis would go like this:</p>
<ul>
<li>
<p><code>foo</code> (prio = 3) and <code>baz</code> (prio = 1) are <code>schedule</code>-able task so the
<code>SysTick</code> must run at the highest priority between these two, that is <code>3</code>.</p>
</li>
<li>
<p><code>foo::Spawn</code> (prio = 3) and <code>bar::Schedule</code> (prio = 2) contend over the
consumer endpoind of <code>baz_FQ</code>; this leads to a priority ceiling of <code>3</code>.</p>
</li>
<li>
<p><code>bar::Schedule</code> (prio = 2) has exclusive access over the consumer endpoint of
<code>foo_FQ</code>; thus the priority ceiling of <code>foo_FQ</code> is effectively <code>2</code>.</p>
</li>
<li>
<p><code>SysTick</code> (prio = 3) and <code>bar::Schedule</code> (prio = 2) contend over the timer
queue <code>TQ</code>; this leads to a priority ceiling of <code>3</code>.</p>
</li>
<li>
<p><code>SysTick</code> (prio = 3) and <code>foo::Spawn</code> (prio = 3) both have lock-free access to
the ready queue <code>RQ3</code>, which holds <code>foo</code> entries; thus the priority ceiling of
<code>RQ3</code> is effectively <code>3</code>.</p>
</li>
<li>
<p>The <code>SysTick</code> has exclusive access to the ready queue <code>RQ1</code>, which holds <code>baz</code>
entries; thus the priority ceiling of <code>RQ1</code> is effectively <code>3</code>.</p>
</li>
</ul>
<a class="header" href="#changes-in-the-spawn-implementation" id="changes-in-the-spawn-implementation"><h2>Changes in the <code>spawn</code> implementation</h2></a>
<p>When the &quot;timer-queue&quot; feature is enabled the <code>spawn</code> implementation changes a
bit to track the baseline of tasks. As you saw in the <code>schedule</code> implementation
there's an <code>INSTANTS</code> buffers used to store the time at which a task was
scheduled to run; this <code>Instant</code> is read in the task dispatcher and passed to
the user code as part of the task context.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const APP: () = {
    // ..

    #[no_mangle]
    unsafe UART1() {
        const PRIORITY: u8 = 1;

        let snapshot = basepri::read();

        while let Some(ready) = RQ1.split().1.dequeue() {
            match ready.task {
                Task::baz =&gt; {
                    let input = baz_INPUTS[ready.index as usize].read();
                    // ADDED
                    let instant = baz_INSTANTS[ready.index as usize].read();

                    baz_FQ.split().0.enqueue_unchecked(ready.index);

                    let priority = Cell::new(PRIORITY);
                    // CHANGED the instant is passed as part the task context
                    baz(baz::Context::new(&amp;priority, instant), input)
                }

                Task::bar =&gt; {
                    // looks just like the `baz` branch
                }

            }
        }

        // BASEPRI invariant
        basepri::write(snapshot);
    }
};
#}</code></pre></pre>
<p>Conversely, the <code>spawn</code> implementation needs to write a value to the <code>INSTANTS</code>
buffer. The value to be written is stored in the <code>Spawn</code> struct and its either
the <code>start</code> time of the hardware task or the <code>scheduled</code> time of the software
task.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    // ..

    pub struct Spawn&lt;'a&gt; {
        priority: &amp;'a Cell&lt;u8&gt;,
        // ADDED
        instant: Instant,
    }

    impl&lt;'a&gt; Spawn&lt;'a&gt; {
        pub unsafe fn priority(&amp;self) -&gt; &amp;Cell&lt;u8&gt; {
            &amp;self.priority
        }

        // ADDED
        pub unsafe fn instant(&amp;self) -&gt; Instant {
            self.instant
        }
    }
}

const APP: () = {
    impl&lt;'a&gt; foo::Spawn&lt;'a&gt; {
        /// Spawns the `baz` task
        pub fn baz(&amp;self, message: u64) -&gt; Result&lt;(), u64&gt; {
            unsafe {
                match lock(self.priority(), baz_FQ_CEILING, || {
                    baz_FQ.split().1.dequeue()
                }) {
                    Some(index) =&gt; {
                        baz_INPUTS[index as usize].write(message);
                        // ADDED
                        baz_INSTANTS[index as usize].write(self.instant());

                        lock(self.priority(), RQ1_CEILING, || {
                            RQ1.split().1.enqueue_unchecked(Ready {
                                task: Task::foo,
                                index,
                            });
                        });

                        rtfm::pend(Interrupt::UART0);
                    }

                    None =&gt; {
                        // maximum capacity reached; spawn failed
                        Err(message)
                    }
                }
            }
        }
    }
};
#}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
